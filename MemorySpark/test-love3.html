<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MemorySparkï½œai.bornforthis.cn AIå®éªŒå®¤</title>
    <link rel="icon" href="https://bornforthis.cn/favicon.ico">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510; /* æ·±è“å¤œç©ºè‰² */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            -webkit-tap-highlight-color: transparent; /* ç§»é™¤ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%); /* æ¸å˜èƒŒæ™¯ */
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            text-align: left;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            pointer-events: none;
            z-index: 12;
            max-width: 80%;
        }

        h1 {
            margin: 0;
            font-weight: 300;
            color: #FFD700; /* Gold */
            letter-spacing: 2px;
            font-size: 24px;
            line-height: 1.4;
        }

        /* æ–°å¢ï¼šç¥ç¦è¯­æ ·å¼ */
        .blessing-text {
            margin: 5px 0;
            font-size: 16px;
            color: #fff;
            font-weight: 400;
            font-style: italic;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
            min-height: 0px; /* æ²¡å†…å®¹æ—¶ä¸å ä½ */
            white-space: pre-wrap; /* æ”¯æŒæ¢è¡Œ */
        }

        p.subtitle {
            margin: 5px 0 0 0;
            color: #aaa;
            font-size: 12px;
            font-family: monospace;
        }
        
        /* ç»Ÿè®¡æ•°æ®æ˜¾ç¤ºæ ·å¼ */
        .pv-display {
            display: inline-block;
            margin-top: 4px;
            font-family: monospace;
            font-size: 12px;
            color: #FFD700;
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        /* Status & Instructions & Buttons Container */
        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Right align everything */
            gap: 12px;
            z-index: 20;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
        }

        .status-tag {
            display: inline-block;
            padding: 8px 16px;
            background: rgba(20, 30, 20, 0.8);
            border: 1px solid #FFD700;
            border-radius: 20px;
            color: #FFD700;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        .instructions {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px; /* Slightly squarer for tech feel */
            font-size: 12px;
            color: #ddd;
            width: 200px; /* Fixed width for alignment */
            pointer-events: auto;
            backdrop-filter: blur(10px);
            border-left: 2px solid #C41E3A; /* Red accent */
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .instruction-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            justify-content: space-between; /* Space out icon and text */
        }
        
        .icon { font-size: 16px; width: 20px; text-align: center;}

        /* Upload Buttons - New Elegant Style */
        .upload-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
            margin-top: 5px;
            width: 220px; /* Give it a bit more width for the dropdown */
        }

        .btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 215, 0, 0.5); /* Subtle Gold Border */
            color: #FFD700;
            padding: 8px 20px;
            border-radius: 4px; /* Minimalist radius */
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
            width: 100%; /* Match width */
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-sizing: border-box; /* Ensure padding doesn't increase width */
        }

        .btn:hover {
            background: rgba(255, 215, 0, 0.15);
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            transform: translateX(-5px); /* Subtle slide left */
        }

        .btn.active {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
            border-color: #FFD700;
        }

        /* Group music buttons slightly */
        .music-group {
            display: flex;
            gap: 5px;
            width: 100%;
        }
        
        .music-group .btn {
            flex: 1; /* Split space */
            padding: 8px 5px; /* Smaller padding */
        }
        
        #music-btn {
            flex: 0 0 40%; /* Play button takes less space */
        }
        
        #playlist-select {
            flex: 1;
            appearance: none; /* Remove default arrow */
            -webkit-appearance: none;
            text-align: left;
            text-align-last: center;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23FFD700' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 12px;
            padding-right: 25px; /* Space for arrow */
            padding-left: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #FFD700;
        }
        
        #playlist-select option {
            background: #222;
            color: #FFD700;
            padding: 5px;
        }

        /* Differentiate clear button slightly */
        #clear-btn {
            border-color: rgba(255, 255, 255, 0.3);
            color: #aaa;
        }
        
        #clear-btn:hover {
            border-color: #fff;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        /* --- Customization Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.open {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid #FFD700;
            border-radius: 10px;
            padding: 25px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.2);
            transform: translateY(20px);
            transition: transform 0.3s ease;
            text-align: left;
        }

        .modal-overlay.open .modal-content {
            transform: translateY(0);
        }

        .modal-content h3 {
            margin: 0 0 20px 0;
            color: #FFD700;
            text-align: center;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            color: #aaa;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .input-group input, .input-group textarea {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            box-sizing: border-box;
            font-family: inherit;
            font-size: 14px;
        }

        .input-group input:focus, .input-group textarea:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }

        .input-group textarea {
            resize: vertical;
            min-height: 60px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-actions button {
            flex: 1;
        }

        .btn.cancel {
            border-color: #666;
            color: #ccc;
        }
        .btn.cancel:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: none;
        }
        .btn.save {
            background: rgba(255, 215, 0, 0.2);
            font-weight: bold;
        }

        #file-input { display: none; }
        #music-input { display: none; }

        /* Webcam feedback (hidden but processed) */
        #video-feed {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            transform: scaleX(-1); /* Mirror */
            border: 2px solid #FFD700;
            opacity: 0.7;
            z-index: 20;
            object-fit: cover;
            display: block; /* Required for MediaPipe */
            pointer-events: none; /* è®©è§†é¢‘ä¸é˜»æŒ¡ç‚¹å‡» */
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #FFD700;
            transition: opacity 0.5s;
        }

        .loader {
            border: 4px solid #333;
            border-top: 4px solid #FFD700;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- ç§»åŠ¨ç«¯é€‚é…é€»è¾‘ --- */

        /* ç§»åŠ¨ç«¯èœå•åˆ‡æ¢æŒ‰é’® (é»˜è®¤éšè—ï¼Œä»…åœ¨ç§»åŠ¨ç«¯æ˜¾ç¤º) */
        #mobile-menu-toggle {
            display: none;
            position: absolute;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #FFD700;
            border-radius: 50%;
            z-index: 30;
            cursor: pointer;
            pointer-events: auto;
            justify-content: center;
            align-items: center;
            color: #FFD700;
            font-size: 20px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        /* ç§»åŠ¨ç«¯æ ·å¼ (æ‰‹æœºç«–å±) */
        @media (max-width: 768px) {
            /* è°ƒæ•´æ ‡é¢˜ä½ç½®ï¼Œé¿å…è¢«æŒ‰é’®é®æŒ¡ */
            .header {
                max-width: 70%;
            }
            .header h1 {
                font-size: 18px;
            }
            .header p.subtitle {
                font-size: 10px;
            }
            .blessing-text {
                font-size: 14px;
            }

            /* æ˜¾ç¤ºæ±‰å ¡èœå•æŒ‰é’® */
            #mobile-menu-toggle {
                display: flex;
            }

            /* éšè—/æŠ˜å èœå•æ  */
            .status-panel {
                /* é»˜è®¤ç§»å‡ºå±å¹• */
                transform: translateX(120%);
                top: 0;
                right: 0;
                height: 100%; /* å…¨é«˜èƒŒæ™¯ */
                background: rgba(0, 0, 0, 0.85); /* æ·±è‰²èƒŒæ™¯ä¾¿äºé˜…è¯» */
                padding: 80px 20px 20px 20px; /* é¡¶éƒ¨ç•™å‡ºæŒ‰é’®ç©ºé—´ */
                box-shadow: -5px 0 20px rgba(0,0,0,0.5);
                border-left: 1px solid rgba(255, 215, 0, 0.2);
                overflow-y: auto; /* å…è®¸å°å±æ»šåŠ¨ */
            }

            /* å½“æ·»åŠ  .active ç±»æ—¶ï¼Œæ»‘å…¥å±å¹• */
            .status-panel.active {
                transform: translateX(0);
            }

            /* è°ƒæ•´è§†é¢‘é¢„è§ˆä½ç½®ï¼Œé˜²æ­¢è¢«å…¨å±èœå•é®æŒ¡ */
            #video-feed {
                width: 120px;
                height: 90px;
                bottom: 10px;
                left: 10px;
            }
        }

    </style>
    <!-- MediaPipe Hands Global Script (Fix for Module Error) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

    <!-- Import Maps for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- ğŸŸ¢ ç»Ÿè®¡ä»£ç æ¥å…¥åŒºåŸŸ -->
    <script
      src="https://counter.bornforthis.cn/counter.js"
      data-domain="ai.bornforthis.cn"
      data-project="auto"
      data-target="#bft-page-pv"
      data-prefix="è®¿é—®é‡: "
    ></script>
    <!-- ç»Ÿè®¡ä»£ç ç»“æŸ -->

</head>
<body>

    <!-- Audio Element (Added crossorigin for recording) -->
    <audio id="bg-music" loop crossorigin="anonymous"></audio>

    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader"></div>
        <div id="loading-text">æ­£åœ¨åˆå§‹åŒ–è§†è§‰å¼•æ“ä¸AIæ¨¡å‹...</div>
    </div>

    <!-- Video Element for MediaPipe (Visible for user feedback) -->
    <video id="video-feed" playsinline></video>

    <!-- Customization Modal (New) -->
    <div id="custom-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>âœ¨ å®šåˆ¶æ‚¨çš„ä¸“å±ç¥ç¦ âœ¨</h3>
            <div class="input-group">
                <label for="input-title">é¡µé¢æ ‡é¢˜ (Header Title)</label>
                <input type="text" id="input-title" placeholder="é»˜è®¤ï¼šåœ£è¯èŠ‚ğŸ„å¿«ä¹..." maxlength="30">
            </div>
            <div class="input-group">
                <label for="input-blessing">ç¥ç¦å¯„è¯­ (Blessing Message)</label>
                <textarea id="input-blessing" placeholder="åœ¨è¿™é‡Œå†™ä¸‹æ‚¨çš„ç¥ç¦è¯­..." maxlength="60"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn cancel" onclick="closeCustomModal()">å–æ¶ˆ</button>
                <button class="btn save" onclick="saveCustomText()">ç¡®è®¤ç”Ÿæˆ</button>
            </div>
        </div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="header">
            <!-- ç»™æ ‡é¢˜å’Œç¥ç¦è¯­åŠ IDä»¥ä¾¿JSæ“ä½œ -->
            <h1 id="main-title">åœ£è¯èŠ‚ğŸ„å¿«ä¹ï¼ï½œBornforthis AIå®éªŒå®¤</h1>
            <div id="blessing-display" class="blessing-text"></div>
            <p class="subtitle">https://ai.bornforthis.cn/</p>
            
            <!-- ğŸŸ¢ ç»Ÿè®¡æ•°æ®æ˜¾ç¤ºåŒºåŸŸ -->
            <!-- counter.js ä¼šè‡ªåŠ¨å¯»æ‰¾ id="bft-page-pv" çš„å…ƒç´ å¹¶å¡«å…¥å†…å®¹ -->
            <span id="bft-page-pv" class="pv-display">æ­£åœ¨è·å–æ•°æ®...</span>
        </div>

        <!-- ç§»åŠ¨ç«¯èœå•åˆ‡æ¢æŒ‰é’® -->
        <div id="mobile-menu-toggle">
            â˜°
        </div>

        <div class="status-panel" id="main-menu">
            <div id="mode-display" class="status-tag">ç­‰å¾…æ‰‹åŠ¿...</div>
            
            <div class="instructions">
                <div class="instruction-item"><span>âœŠ æ¡æ‹³</span> <span>èšåˆå½¢æ€</span></div>
                <div class="instruction-item"><span>ğŸ– å¼ å¼€</span> <span>æ•£å¼€å½¢æ€</span></div>
                <div class="instruction-item"><span>ğŸ¤ æåˆ</span> <span>ç‰¹å†™ç…§ç‰‡</span></div>
                <div class="instruction-item"><span>ğŸ‘‹ ç§»åŠ¨</span> <span>æ—‹è½¬è§†è§’</span></div>
                <div class="instruction-item"><span>ğŸ¤Ÿ ç¤ºçˆ±</span> <span>è·³åŠ¨çˆ±å¿ƒ</span></div>
            </div>

            <div class="upload-container">
                <!-- æ–°å¢ï¼šå®šåˆ¶ç¥ç¦æŒ‰é’® -->
                <button id="custom-btn" class="btn" onclick="openCustomModal()">
                    <span>âœï¸</span> å®šåˆ¶ç¥ç¦
                </button>

                <button id="upload-btn" class="btn" onclick="document.getElementById('file-input').click()">
                    <span>ğŸ“·</span> ä¸Šä¼ ç…§ç‰‡
                </button>
                
                <!-- æ–°å¢ï¼šä½“éªŒé»˜è®¤ç…§ç‰‡æŒ‰é’® -->
                <button id="default-photos-btn" class="btn" onclick="loadDefaultPhotos()">
                    <span>ğŸ–¼ï¸</span> ä½“éªŒé»˜è®¤ç…§ç‰‡
                </button>

                <!-- Music Controls -->
                <div class="music-group">
                    <button id="music-btn" class="btn" onclick="toggleMusic()">
                        <span>ğŸ”‡</span>
                    </button>
                    <!-- ä¸‹æ‹‰é€‰æ‹©æ¡†æ›¿ä»£åŸæ¥çš„â€œæ¢éŸ³ä¹â€æŒ‰é’® -->
                    <select id="playlist-select" class="btn" onchange="handlePlaylistChange(this)">
                        <option disabled>-- é€‰æ‹©èƒŒæ™¯éŸ³ä¹ --</option>
                        <!-- Options will be populated by JS -->
                        <option value="custom">ğŸ“‚ è‡ªå®šä¹‰...</option>
                    </select>
                </div>

                <button id="clear-btn" class="btn" onclick="clearCachedPhotos()">
                    <span>ğŸ—‘ï¸</span> æ¸…é™¤ç…§ç‰‡
                </button>
                
                <input type="file" id="file-input" accept="image/*" multiple onchange="handlePhotoUpload(event)">
                <!-- æ–°å¢éŸ³ä¹æ–‡ä»¶è¾“å…¥æ¡† -->
                <input type="file" id="music-input" accept="audio/*, .mp3, .m4a" onchange="handleMusicFileUpload(event)">
            </div>
        </div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';

        // --- Configuration & Constants ---
        const CONFIG = {
            colors: {
                green: 0x228B22,   // Forest Green
                heartRed: 0xFF0066, // New: Vibrant Romantic Red/Pink for Heart Mode
                gold: 0xFFD700,    // Metallic Gold
                red: 0xFF0000,     // Bright Red
                white: 0xFFFFFF,
                // æ–°å¢ç¯å…‰é¢œè‰²æ± 
                lights: [0xFF0000, 0xFFFF00, 0x00BFFF, 0xFF69B4, 0xFFA500] 
            },
            particles: 1800,       // ç¨å¾®å¢åŠ ç²’å­æ•°é‡åˆ° 1800ï¼Œå®¹çº³æ›´å¤šè£…é¥°
            radius: 18,            // Base radius of tree bottom
            height: 35,            // Height of tree
            cacheKey: 'xmas_tree_photos_v1',
            cacheDuration: 7 * 24 * 60 * 60 * 1000, // 7 Days in ms
            musicCacheKey: 'xmas_music_pref_v3', // æ›´æ–°ç‰ˆæœ¬å·ä»¥é€‚åº”æ–°é€»è¾‘
            textCacheKey: 'xmas_custom_text_v1', // æ–°å¢ï¼šæ–‡æœ¬ç¼“å­˜ Key
            
            // å†…ç½®æ­Œå•
            playlist: [
                { name: "Last Christmas", url: "https://cdn.bornforthis.cn/mp3/LastChristmas(Single%20Version).m4a" },
                { name: "Jingle Bell Rock", url: "https://cdn.bornforthis.cn/mp3/JingleBellRock.m4a" },
                { name: "Santa Tell Me", url: "https://cdn.bornforthis.cn/mp3/SantaTellMe.m4a" },
                { name: "Feliz Navidad", url: "https://cdn.bornforthis.cn/mp3/FelizNavidad.m4a" },
                { name: "Santa Claus is Coming", url: "https://cdn.bornforthis.cn/mp3/SantaClausisComingtoTown.m4a" },
                { name: "Here Comes Santa Claus", url: "https://cdn.bornforthis.cn/mp3/HereComesSantaClaus.m4a" },
                { name: "Merry Christmas Mr Lawrence", url: "https://cdn.bornforthis.cn/mp3/MerryChristmasMrLawrence.m4a" },
                { name: "Christmas Time in My Town", url: "https://cdn.bornforthis.cn/mp3/ChristmasTimeinMyHomeTown.mp3" },
            ],

            // é»˜è®¤ç…§ç‰‡åˆ—è¡¨
            defaultPhotos: [
                "./images_compressed/DSC02094.JPG", // å›¾ç‰‡ 1
                "./images_compressed/DSC02182.JPG", // å›¾ç‰‡ 2
                "./images_compressed/DSC02410.JPG", // å›¾ç‰‡ 3
                "./images_compressed/DSC02464.JPG", // å›¾ç‰‡ 4
                "./images_compressed/DSC02503.JPG", // å›¾ç‰‡ 5
                "./images_compressed/DSC02506.JPG", // å›¾ç‰‡ 6
                "./images_compressed/DSC02527.JPG", // å›¾ç‰‡ 7
                "./images_compressed/DSC02533.JPG", // å›¾ç‰‡ 8
                "./images_compressed/DSC02599.JPG", // å›¾ç‰‡ 9
                "./images_compressed/DSC02602.JPG", // å›¾ç‰‡ 10
                "./images_compressed/DSC02605.JPG", // å›¾ç‰‡ 11
                "./images_compressed/DSC02608.JPG", // å›¾ç‰‡ 12
                "./images_compressed/DSC02707.JPG", // å›¾ç‰‡ 13
                "./images_compressed/DSC02752.JPG", // å›¾ç‰‡ 14
                "./images_compressed/DSC02863.JPG", // å›¾ç‰‡ 15
                "./images_compressed/DSC02866.JPG", // å›¾ç‰‡ 16
                "./images_compressed/DSC02869.JPG", // å›¾ç‰‡ 17
                "./images_compressed/DSC02878.JPG", // å›¾ç‰‡ 18
                "./images_compressed/DSC02908.JPG", // å›¾ç‰‡ 19
                "./images_compressed/DSC02959.JPG", // å›¾ç‰‡ 20
                "./images_compressed/DSC02983.JPG", // å›¾ç‰‡ 21
                "./images_compressed/DSC03010.JPG", // å›¾ç‰‡ 22
                "./images_compressed/DSC03016.JPG", // å›¾ç‰‡ 23
                "./images_compressed/DSC03019.JPG", // å›¾ç‰‡ 24
                "./images_compressed/DSC03025.JPG", // å›¾ç‰‡ 25
                "./images_compressed/DSC03124.JPG"  // å›¾ç‰‡ 26
            ]
        };

        // --- Global Variables ---
        let scene, camera, renderer;
        let particles = []; // Array to store { mesh, treePos, explodePos, heartPos, currentPos, speed }
        let photoMeshes = []; // Array specifically for user photos
        let twinkleLights = []; // ä¸“é—¨å­˜å‚¨éœ€è¦é—ªçƒçš„ç¯å…‰ç²’å­
        let matGreen; // Globalize material for color changing
        
        // æ–°å¢çš„ç‰¹æ•ˆç³»ç»Ÿ
        let snowParticles, magicDust;
        
        let time = 0;
        
        // Interaction State
        const STATE = {
            TREE: 'TREE',
            EXPLODE: 'EXPLODE',
            FOCUS: 'FOCUS',
            HEART: 'HEART' // æ–°å¢å¿ƒå½¢æ¨¡å¼
        };
        let currentState = STATE.TREE;
        let targetState = STATE.TREE;
        
        // Hand Data
        let handPos = { x: 0, y: 0 }; // Normalized -1 to 1
        let isHandDetected = false;

        // Music State
        let isMusicPlaying = false;
        let currentMusicSource = CONFIG.playlist[0].url; // Default to first song

        // --- Initialization ---
        async function init() {
            // 1. Scene Setup
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // ç§»é™¤çº¯è‰²èƒŒæ™¯ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ CSS é‡Œç”¨äº†æ¸å˜ï¼Œè¿™é‡Œè®¾ä¸ºé€æ˜æˆ–ä¿ç•™é›¾æ•ˆæœ
            scene.background = null; 
            // å¢åŠ ä¸€ç‚¹é›¾æ°”å¢åŠ æ·±é‚ƒæ„Ÿ
            scene.fog = new THREE.FogExp2(0x050510, 0.01);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            // 2. Lighting - å¤§å¹…å¢å¼ºå…‰ç…§
            // 2.1 å¼ºç¯å¢ƒå…‰ï¼Œç…§äº®æ‰€æœ‰é˜´å½±
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); 
            scene.add(ambientLight);

            // 2.2 ä¸»å¹³è¡Œå…‰ï¼ˆæ¨¡æ‹Ÿé˜³å…‰ï¼‰ï¼Œæä¾›æ¸…æ™°çš„æ˜æš—å…³ç³»
            const mainLight = new THREE.DirectionalLight(0xffffff, 2.0);
            mainLight.position.set(10, 20, 20);
            scene.add(mainLight);

            // 2.3 è¡¥å…‰ç¯ï¼ˆé‡‘è‰²ï¼‰ï¼Œå¢åŠ åä¸½æ„Ÿ
            const pointLight = new THREE.PointLight(CONFIG.colors.gold, 1.5, 100);
            pointLight.position.set(0, 20, 10);
            scene.add(pointLight);
            
            // 2.4 æ°›å›´ç¯ï¼ˆçº¢ç»¿ï¼‰ï¼Œå¢åŠ èŠ‚æ—¥æ°”æ°›ï¼Œä½†è°ƒé«˜äº®åº¦
            const redLight = new THREE.PointLight(CONFIG.colors.red, 1.5, 50);
            redLight.position.set(15, 10, 15);
            scene.add(redLight);
            
            const greenLight = new THREE.PointLight(CONFIG.colors.green, 1.5, 50);
            greenLight.position.set(-15, -10, 15);
            scene.add(greenLight);

            // 3. Post Processing Removed

            // 4. Content Generation
            createParticles();
            createLightStrip(); // æ–°å¢ï¼šèºæ—‹ç¯å¸¦
            createStar();
            createEnvironment(); // æ–°å¢ï¼šæ˜Ÿç©º
            createSnow();        // æ–°å¢ï¼šé›ªèŠ±
            createMagicDust();   // æ–°å¢ï¼šé­”æ³•é‡‘ç²‰
            
            // 5. Load Cached Data
            loadCachedPhotos();
            loadCustomText(); // æ–°å¢ï¼šåŠ è½½è‡ªå®šä¹‰æ ‡é¢˜å’Œç¥ç¦
            initAudio(); // åˆå§‹åŒ–éŸ³é¢‘å’Œä¸‹æ‹‰èœå•

            // 6. Setup MediaPipe
            await setupMediaPipe();

            // 7. Events
            window.addEventListener('resize', onWindowResize);
            
            // --- Mobile Menu Event Logic ---
            setupMobileMenuInteractions();

            // 8. Start Loop
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
            animate();
        }

        // --- Custom Text Logic (Title & Blessing) ---
        
        // é»˜è®¤æ ‡é¢˜æ–‡æœ¬
        const DEFAULT_TITLE = "åœ£è¯èŠ‚ğŸ„å¿«ä¹ï¼PPro Maxï½œBornforthis AIå®éªŒå®¤";

        window.openCustomModal = function() {
            const modal = document.getElementById('custom-modal');
            const titleInput = document.getElementById('input-title');
            const blessingInput = document.getElementById('input-blessing');
            
            // å¡«å……å½“å‰å€¼
            const currentTitle = document.getElementById('main-title').innerText;
            const currentBlessing = document.getElementById('blessing-display').innerText;
            
            // å¦‚æœæ˜¯é»˜è®¤æ ‡é¢˜ï¼Œè¾“å…¥æ¡†æ˜¾ç¤ºä¸ºç©ºï¼ˆä½œä¸ºplaceholderæ˜¾ç¤ºï¼‰
            titleInput.value = (currentTitle === DEFAULT_TITLE) ? "" : currentTitle;
            blessingInput.value = currentBlessing;
            
            modal.style.display = 'flex';
            // Force reflow for transition
            setTimeout(() => modal.classList.add('open'), 10);
        };

        window.closeCustomModal = function() {
            const modal = document.getElementById('custom-modal');
            modal.classList.remove('open');
            setTimeout(() => modal.style.display = 'none', 300);
        };

        window.saveCustomText = function() {
            const titleInput = document.getElementById('input-title').value.trim();
            const blessingInput = document.getElementById('input-blessing').value.trim();
            
            // æ›´æ–° UI
            const titleToSet = titleInput || DEFAULT_TITLE; // ä¸ºç©ºåˆ™æ¢å¤é»˜è®¤
            document.getElementById('main-title').innerText = titleToSet;
            document.title = titleToSet.replace(/\|/g, '-'); // åŒæ—¶ä¹Ÿæ›´æ–°æµè§ˆå™¨æ ‡ç­¾é¡µæ ‡é¢˜
            
            const blessingEl = document.getElementById('blessing-display');
            blessingEl.innerText = blessingInput;
            
            // ä¿å­˜åˆ°ç¼“å­˜
            const dataToSave = {
                timestamp: Date.now(),
                title: titleInput, // å­˜åŸå§‹è¾“å…¥
                blessing: blessingInput
            };
            
            try {
                localStorage.setItem(CONFIG.textCacheKey, JSON.stringify(dataToSave));
                // å¦‚æœæ‰€æœ‰å†…å®¹éƒ½ä¸ºç©ºï¼Œå…¶å®å¯ä»¥åˆ é™¤ç¼“å­˜ä»¥èŠ‚çœç©ºé—´
                if (!titleInput && !blessingInput) {
                    localStorage.removeItem(CONFIG.textCacheKey);
                }
            } catch(e) {
                console.warn("Saving text failed", e);
            }
            
            closeCustomModal();
        };

        function loadCustomText() {
            try {
                const raw = localStorage.getItem(CONFIG.textCacheKey);
                if (!raw) return;
                
                const data = JSON.parse(raw);
                const now = Date.now();
                
                // æ£€æŸ¥æœ‰æ•ˆæœŸ (7å¤©)
                if (now - data.timestamp <= CONFIG.cacheDuration) {
                    if (data.title) {
                        document.getElementById('main-title').innerText = data.title;
                        document.title = data.title.replace(/\|/g, '-');
                    }
                    if (data.blessing) {
                        document.getElementById('blessing-display').innerText = data.blessing;
                    }
                } else {
                    // è¿‡æœŸæ¸…é™¤
                    localStorage.removeItem(CONFIG.textCacheKey);
                }
            } catch(e) {
                console.error("Failed to load custom text", e);
            }
        }

        // --- Mobile Menu Interaction Logic ---
        function setupMobileMenuInteractions() {
            const toggleBtn = document.getElementById('mobile-menu-toggle');
            const mainMenu = document.getElementById('main-menu');

            // 1. Toggle Button Click
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘ document ç‚¹å‡»
                mainMenu.classList.toggle('active');
                
                // æ›´æ–°å›¾æ ‡
                if (mainMenu.classList.contains('active')) {
                    toggleBtn.innerHTML = 'âœ•'; // å…³é—­å›¾æ ‡
                } else {
                    toggleBtn.innerHTML = 'â˜°'; // èœå•å›¾æ ‡
                }
            });

            // 2. Click Inside Menu (Prevent closing)
            mainMenu.addEventListener('click', (e) => {
                // ç‚¹å‡»èœå•å†…éƒ¨æ—¶ä¸å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘ document çš„å…³é—­é€»è¾‘
                e.stopPropagation();
            });

            // 3. Click Outside (Document)
            document.addEventListener('click', () => {
                // å¦‚æœæ˜¯ç§»åŠ¨ç«¯ä¸”èœå•å·²æ‰“å¼€
                if (window.innerWidth <= 768 && mainMenu.classList.contains('active')) {
                    mainMenu.classList.remove('active');
                    toggleBtn.innerHTML = 'â˜°';
                }
            });
            
            // 4. Touch Start on Canvas (Better UX for mobile 3D interaction)
            // å½“ç”¨æˆ·åœ¨ canvas ä¸Šå¼€å§‹æ»‘åŠ¨æ“ä½œæ—¶ï¼Œä¹Ÿåº”è¯¥å…³é—­èœå•
            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.addEventListener('touchstart', () => {
                if (window.innerWidth <= 768 && mainMenu.classList.contains('active')) {
                    mainMenu.classList.remove('active');
                    toggleBtn.innerHTML = 'â˜°';
                }
            }, { passive: true });
        }

        // --- MediaPipe Logic ---
        async function setupMediaPipe() {
            const video = document.getElementById('video-feed');

            // Access Global Hands Class
            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.6
            });

            hands.onResults(onHandsResults);

            // Access Webcam
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                await video.play();

                // Start processing loop specific to MediaPipe
                async function detectionLoop() {
                    if (video.currentTime > 0 && !video.paused && !video.ended) {
                        await hands.send({image: video});
                    }
                    requestAnimationFrame(detectionLoop);
                }
                detectionLoop();
            } catch (err) {
                console.error("Camera access denied or failed", err);
                document.getElementById('loading-text').innerText = "æœªæ£€æµ‹åˆ°æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚åº”ç”¨å°†è‡ªåŠ¨è¿è¡Œæ¼”ç¤ºæ¨¡å¼ã€‚";
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    // Auto demo mode logic could go here
                }, 2000);
            }
        }

        function onHandsResults(results) {
            const modeDisplay = document.getElementById('mode-display');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. Calculate Hand Center (for rotation)
                // Wrist is 0, Middle Finger MCP is 9
                const cx = landmarks[9].x;
                const cy = landmarks[9].y;
                handPos.x = (cx - 0.5) * 2; // -1 to 1
                handPos.y = (cy - 0.5) * 2;

                // 2. Gesture Recognition
                const state = detectGesture(landmarks);
                
                if (state) {
                    targetState = state;
                    
                    // UI Update
                    let text = "æœªçŸ¥";
                    let bg = "#333";
                    let color = CONFIG.colors.gold;

                    if (state === STATE.TREE) { text = "ğŸŒ² èšåˆå½¢æ€"; bg = CONFIG.colors.green; }
                    else if (state === STATE.EXPLODE) { text = "âœ¨ æ•£å¼€å½¢æ€"; bg = "#444"; }
                    else if (state === STATE.FOCUS) { text = "ğŸ“· èšç„¦ç…§ç‰‡"; bg = CONFIG.colors.red; color = "#fff"; }
                    else if (state === STATE.HEART) { text = "â¤ï¸ å¿ƒåŠ¨æ¨¡å¼"; bg = "#E91E63"; color = "#fff"; }
                    
                    modeDisplay.innerText = text;
                    modeDisplay.style.borderColor = color;
                    modeDisplay.style.color = color;
                }

            } else {
                isHandDetected = false;
            }
        }

        function detectGesture(lm) {
            const dist = (i, j) => Math.sqrt(Math.pow(lm[i].x - lm[j].x, 2) + Math.pow(lm[i].y - lm[j].y, 2));
            const wrist = 0;
            const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky Tips
            const pips = [6, 10, 14, 18]; // PIP Joints
            
            // Check Fingers Extended
            let extendedCount = 0;
            if (dist(4, 17) > 0.2) extendedCount++; // Rough thumb check

            for (let k=0; k<4; k++) {
                if (dist(wrist, tips[k]) > dist(wrist, pips[k]) * 1.2) {
                    extendedCount++;
                }
            }

            // Pinch Detection (Thumb 4 and Index 8)
            const pinchDist = dist(4, 8);

            // New: Love Gesture ğŸ¤Ÿ Detection (Thumb, Index, Pinky Open; Middle, Ring Closed)
            // Thumb Open
            const isThumbOpen = dist(4, 17) > 0.2; 
            // Index Open
            const isIndexOpen = dist(wrist, 8) > dist(wrist, 6) * 1.2;
            // Pinky Open
            const isPinkyOpen = dist(wrist, 20) > dist(wrist, 18) * 1.2;
            // Middle Closed
            const isMiddleClosed = dist(wrist, 12) < dist(wrist, 10) * 1.2; // Strict close check not always needed, open check fails usually enough
            // Ring Closed
            const isRingClosed = dist(wrist, 16) < dist(wrist, 14) * 1.2;

            if (isThumbOpen && isIndexOpen && isPinkyOpen && !isIndexOpen == false && !isPinkyOpen == false && extendedCount === 3) {
                 // Check Middle/Ring being closed more strictly if needed, but usually count=3 with specific fingers is enough
                 // However, simpler check:
                 if (isMiddleClosed && isRingClosed) {
                     return STATE.HEART;
                 }
            }

            if (pinchDist < 0.08) {
                return STATE.FOCUS;
            } else if (extendedCount >= 4) {
                return STATE.EXPLODE;
            } else if (extendedCount <= 1) {
                return STATE.TREE;
            }
            
            return null; 
        }

        // --- Audio Logic ---
        
        function initAudio() {
            // 1. Populate Dropdown
            const select = document.getElementById('playlist-select');
            
            // Insert Built-in options BEFORE the "Custom" option
            CONFIG.playlist.forEach(song => {
                const option = document.createElement('option');
                option.value = song.url;
                option.innerText = `ğŸµ ${song.name}`;
                // Insert before the last option (which is Custom)
                select.insertBefore(option, select.lastElementChild);
            });

            // 2. Error Handling & Fallback
            const audio = document.getElementById('bg-music');
            
            // Critical fix for "The element has no supported sources"
            audio.addEventListener('error', function(e) {
                console.warn("Audio load error:", e);
                const src = audio.src;
                // If it failed and we had crossorigin set, try removing it (fallback mode)
                // This means audio won't be recordable via WebAudio, but at least it plays.
                if (audio.crossOrigin === 'anonymous') {
                    console.log("Attempting fallback: Removing crossorigin attribute...");
                    audio.removeAttribute('crossorigin');
                    audio.src = src; // Retry
                    audio.load();
                    if (isMusicPlaying) audio.play().catch(err => console.log("Fallback play error:", err));
                }
            }, true); // Capture phase

            // 3. Load Preferences
            try {
                const raw = localStorage.getItem(CONFIG.musicCacheKey);
                if (raw) {
                    const cache = JSON.parse(raw);
                    const now = Date.now();
                    
                    if (now - cache.timestamp <= CONFIG.cacheDuration) {
                        // æ¢å¤éŸ³ä¹æº
                        if (cache.customSrc) {
                            currentMusicSource = cache.customSrc;
                        }

                        // æ¢å¤æ’­æ”¾çŠ¶æ€
                        if (cache.enabled) {
                            isMusicPlaying = true;
                            // Play will be called below
                        }
                    }
                }
            } catch (e) {
                console.error("Error loading music preference", e);
            }

            // 4. Apply Source
            audio.src = currentMusicSource;
            
            // 5. Sync Dropdown Value
            // Check if current source is in playlist
            const inPlaylist = CONFIG.playlist.find(p => p.url === currentMusicSource);
            if (inPlaylist) {
                select.value = currentMusicSource;
            } else {
                // If not in playlist, it stays default or handled by custom
            }

            // 6. Play if needed
            updateMusicUI(isMusicPlaying);
            if (isMusicPlaying) {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log("Auto-play blocked or source invalid:", error);
                        // Don't turn off isMusicPlaying immediately if it's just blocking;
                        // But if it's a source error, the 'error' listener handles it.
                        // If it's policy block, we update UI
                        if (error.name === 'NotAllowedError') {
                             isMusicPlaying = false;
                             updateMusicUI(false);
                        }
                    });
                }
            }
        }

        // å¤„ç†ä¸‹æ‹‰èœå•å˜åŒ–
        window.handlePlaylistChange = function(selectElem) {
            const value = selectElem.value;
            
            if (value === 'custom') {
                // ç”¨æˆ·é€‰æ‹©â€œè‡ªå®šä¹‰â€
                handleCustomMusicClick();
                // æš‚æ—¶æŠŠé€‰ä¸­çš„å€¼é‡ç½®å›ä¹‹å‰çš„ï¼ˆæˆ–è€…ä¿æŒ Customï¼‰ï¼Œç­‰å¾…ç”¨æˆ·å®Œæˆä¸Šä¼ 
                // å®é™…ä¸Š handleCustomMusicClick ä¼šæ›´æ–°æº
            } else {
                // ç”¨æˆ·é€‰æ‹©äº†å†…ç½®æ­Œæ›²
                changeMusicSource(value, 'builtin');
            }
        };

        window.handleCustomMusicClick = function() {
            const url = prompt("è¯·è¾“å…¥èƒŒæ™¯éŸ³ä¹é“¾æ¥ (MP3/M4A)\næˆ–è€…ç‚¹å‡» [å–æ¶ˆ] ä¸Šä¼ æœ¬åœ°æ–‡ä»¶:");
            
            if (url) {
                changeMusicSource(url.trim(), 'link');
            } else if (url === "") {
                // Cancelled or empty
                // Revert selection if possible?
            } else {
                // Clicked Cancel -> File Upload
                document.getElementById('music-input').click();
            }
        };

        window.handleMusicFileUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const result = e.target.result;
                const canCache = result.length < 4 * 1024 * 1024; 
                changeMusicSource(result, 'file', canCache);
                if (!canCache) {
                    alert("éŸ³ä¹æ–‡ä»¶è¾ƒå¤§ï¼Œä»…åœ¨æœ¬æ¬¡è®¿é—®æ’­æ”¾ï¼Œä¸ä¼šç¼“å­˜åˆ°æœ¬åœ°ã€‚");
                }
            };
            reader.readAsDataURL(file);
            event.target.value = ''; 
        };

        function changeMusicSource(src, type, shouldCache = true) {
            const audio = document.getElementById('bg-music');
            currentMusicSource = src;
            
            // Reset crossorigin if it was removed by fallback previously, to try recording again if possible
            if (!audio.hasAttribute('crossorigin') && type !== 'file') { // Local files don't need CORS
                 audio.setAttribute('crossorigin', 'anonymous');
            }
            
            audio.src = src;
            
            // Auto play
            isMusicPlaying = true;
            audio.play().catch(e => console.log("Play interrupted or failed:", e));
            updateMusicUI(true);
            
            // Update Dropdown UI to reflect change
            const select = document.getElementById('playlist-select');
            // If it's a built-in type, select matches src
            if (type === 'builtin') {
                 select.value = src;
            }
            
            // Save
            saveMusicPreference(true, shouldCache ? src : null);
        }

        window.toggleMusic = function() {
            const audio = document.getElementById('bg-music');
            isMusicPlaying = !isMusicPlaying;
            
            if (isMusicPlaying) {
                audio.play().catch(e => {
                    console.log("Play failed in toggle:", e);
                    // Revert UI if play fails hard
                    isMusicPlaying = false;
                    updateMusicUI(false);
                });
            } else {
                audio.pause();
            }
            
            updateMusicUI(isMusicPlaying);
            // Save state (keep existing src)
            saveMusicPreference(isMusicPlaying, null, true); 
        };

        function updateMusicUI(isPlaying) {
            const btn = document.getElementById('music-btn');
            if (isPlaying) {
                btn.innerHTML = '<span>ğŸ”Š</span>';
                btn.classList.add('active');
            } else {
                btn.innerHTML = '<span>ğŸ”‡</span>';
                btn.classList.remove('active');
            }
        }

        // srcData: å¦‚æœä¸ä¸º nullï¼Œåˆ™æ›´æ–° customSrcï¼›å¦‚æœä¸º null ä¸” updateOnlyState=falseï¼Œåˆ™æ¸…é™¤ customSrc
        // updateOnlyState: å¦‚æœä¸º trueï¼Œåªæ›´æ–°å¼€å…³çŠ¶æ€ï¼Œä¸ç¢° source
        function saveMusicPreference(isEnabled, srcData = null, updateOnlyState = false) {
            try {
                let dataToSave = {
                    timestamp: Date.now(),
                    enabled: isEnabled,
                    customSrc: null
                };

                if (updateOnlyState) {
                    const oldRaw = localStorage.getItem(CONFIG.musicCacheKey);
                    if (oldRaw) {
                        const old = JSON.parse(oldRaw);
                        dataToSave.customSrc = old.customSrc;
                    }
                } else {
                    dataToSave.customSrc = srcData;
                }

                localStorage.setItem(CONFIG.musicCacheKey, JSON.stringify(dataToSave));
            } catch (e) {
                console.warn("Failed to save music preference", e);
                // Fallback: save disabled state without source
                try {
                      const fallbackData = {
                        timestamp: Date.now(),
                        enabled: isEnabled,
                        customSrc: null 
                    };
                    localStorage.setItem(CONFIG.musicCacheKey, JSON.stringify(fallbackData));
                } catch(e2) {}
            }
        }

        // --- Visual Effects Creation ---

        function createEnvironment() {
            // Stars
            const starsGeo = new THREE.BufferGeometry();
            const starsCount = 2000;
            const posArray = new Float32Array(starsCount * 3);
            
            for(let i=0; i<starsCount*3; i++) {
                // Distant stars
                posArray[i] = (Math.random() - 0.5) * 400; 
            }
            
            starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const starsMat = new THREE.PointsMaterial({
                size: 0.5,
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            const starField = new THREE.Points(starsGeo, starsMat);
            scene.add(starField);
        }

        // --- åŠ¨æ€ç”Ÿæˆé›ªèŠ±çº¹ç† ---
        function createSnowflakeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');

            // ç»˜åˆ¶é›ªèŠ±å½¢çŠ¶ (å…­è§’æ˜Ÿ)
            context.strokeStyle = '#FFFFFF';
            context.lineWidth = 2;
            context.lineCap = 'round';
            
            context.translate(16, 16);
            for(let i = 0; i < 6; i++) {
                context.beginPath();
                context.moveTo(0, 0);
                context.lineTo(0, 14);
                context.stroke();
                
                // å°åˆ†å‰
                context.beginPath();
                context.moveTo(0, 8);
                context.lineTo(4, 10);
                context.stroke();
                
                context.beginPath();
                context.moveTo(0, 8);
                context.lineTo(-4, 10);
                context.stroke();
                
                context.rotate(Math.PI / 3);
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createSnow() {
            const snowGeo = new THREE.BufferGeometry();
            const snowCount = 500;
            const posArray = new Float32Array(snowCount * 3);
            const velArray = new Float32Array(snowCount); // Falling speed
            
            for(let i=0; i<snowCount; i++) {
                const i3 = i * 3;
                posArray[i3] = (Math.random() - 0.5) * 80; // x
                posArray[i3+1] = (Math.random() - 0.5) * 80 + 20; // y (start high)
                posArray[i3+2] = (Math.random() - 0.5) * 80; // z
                
                velArray[i] = 0.1 + Math.random() * 0.1; // speed
            }
            
            snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            // ä½¿ç”¨ç”Ÿæˆçš„é›ªèŠ±çº¹ç†
            const snowTexture = createSnowflakeTexture();

            const snowMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2.0, // è°ƒå¤§å°ºå¯¸ä»¥æ˜¾ç¤ºå›¾æ¡ˆ
                map: snowTexture,
                transparent: true,
                opacity: 0.8,
                depthWrite: false, // é¿å…é€æ˜é®æŒ¡é—®é¢˜
                blending: THREE.AdditiveBlending 
            });
            
            snowParticles = new THREE.Points(snowGeo, snowMat);
            snowParticles.userData = { velocities: velArray };
            scene.add(snowParticles);
        }

        function createMagicDust() {
            const dustGeo = new THREE.BufferGeometry();
            const count = 300;
            const posArray = new Float32Array(count * 3);
            
            for(let i=0; i<count*3; i++) {
                posArray[i] = (Math.random() - 0.5) * 40; 
            }
            
            dustGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const dustMat = new THREE.PointsMaterial({
                color: 0xFFD700, // Gold
                size: 0.3,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            magicDust = new THREE.Points(dustGeo, dustMat);
            scene.add(magicDust);
        }

        // --- Particle System Logic ---

        // ç§»é™¤æ—§çš„èºæ—‹çº¿é€»è¾‘ï¼Œæ”¹ç”¨ä½“ç§¯è®¡ç®—
        function getConeVolumePosition(h, maxR) {
            // h is 0 (bottom) to 1 (top)
            
            // å½“å‰é«˜åº¦çš„åœ†é”¥æˆªé¢åŠå¾„
            const rAtHeight = maxR * (1 - h);
            
            // éšæœºåˆ†å¸ƒåœ¨åœ†æˆªé¢å†…ï¼Œä½†æ›´å€¾å‘äºå¤–è¡¨é¢ä»¥ä¿æŒæ ‘çš„å½¢çŠ¶
            // ä½¿ç”¨ Math.pow è°ƒæ•´åˆ†å¸ƒï¼šæŒ‡æ•°è¶Šå°è¶Šå‡åŒ€ï¼ŒæŒ‡æ•°è¶Šå¤§è¶Šé›†ä¸­åœ¨è¾¹ç¼˜
            const r = rAtHeight * Math.pow(Math.random(), 0.4); 
            
            const angle = Math.random() * Math.PI * 2;
            
            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);
            
            // å°†é«˜åº¦æ˜ å°„åˆ°å®é™…åæ ‡ y
            const y = -CONFIG.height/2 + h * CONFIG.height;
            
            return new THREE.Vector3(x, y, z);
        }

        // æ–°å¢ï¼šä¸“é—¨ç”¨äºæ•£å¼€å½¢æ€çš„çƒä½“åˆ†å¸ƒç®—æ³• (åœ†å½¢)
        function getExplodeSpherePosition(maxRadius) {
            // çƒåæ ‡éšæœºåˆ†å¸ƒ
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            
            // ä½¿ç”¨ç«‹æ–¹æ ¹ç¡®ä¿åœ¨ä½“ç§¯å†…å‡åŒ€åˆ†å¸ƒï¼ˆä¸ä»…ä»…æ˜¯è¡¨é¢ï¼Œä¹Ÿä¸ä»…ä»…æ˜¯æ ¸å¿ƒï¼‰
            const r = maxRadius * Math.cbrt(Math.random()); 
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            return new THREE.Vector3(x, y, z);
        }
        
        // æ–°å¢ï¼šçˆ±å¿ƒå½¢æ€ä½ç½®è®¡ç®— (3D Thick Extrusion)
        // ä½¿ç”¨ 2D å¿ƒå½¢å…¬å¼å¹¶å¢åŠ  Z è½´åšåº¦
        function getHeartVolumePosition() {
             // éšæœº t (0 - 2PI)
             const t = Math.random() * Math.PI * 2;
             
             // éšæœº r (åŠå¾„æ¯”ä¾‹)ï¼Œä½¿ç”¨ sqrt ä¿è¯é¢ç§¯å‡åŒ€åˆ†å¸ƒ
             // 0.2 gap at center makes it look less dense in core if desired, or just full 0-1
             const r = Math.sqrt(Math.random()); 
             
             // åŸºç¡€ 2D å¿ƒå½¢æ–¹ç¨‹
             const xBase = 16 * Math.pow(Math.sin(t), 3);
             const yBase = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
             
             // åº”ç”¨åŠå¾„ç¼©æ”¾
             const x = xBase * r;
             const y = yBase * r;
             
             // Z è½´éšæœºåšåº¦ (-2 åˆ° 2)
             const z = (Math.random() - 0.5) * 4;
             
             // æ•´ä½“ç¼©æ”¾å’Œä½ç§»
             const s = 1.0; 
             return new THREE.Vector3(x * s, (y * s) + 5, z * s);
        }

        // æ–°å¢ï¼šä¸“é—¨ç”¨äºç…§ç‰‡çš„å‡åŒ€åˆ†å¸ƒç®—æ³• (åŸºäºé»„é‡‘è§’åº¦èºæ—‹)
        function getPhotoSurfacePosition(index) {
            const goldenRatio = 0.61803398875;
            const h = ((index * goldenRatio) % 0.7) + 0.15; 
            const angle = index * Math.PI * 2 * goldenRatio;
            const rBase = CONFIG.radius * (1 - h);
            const r = rBase + 2.5; 
            
            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);
            const y = -CONFIG.height/2 + h * CONFIG.height;
            
            return new THREE.Vector3(x, y, z);
        }

        // æ–°å¢ï¼šèºæ—‹ç¯å¸¦ç”Ÿæˆå‡½æ•°
        function createLightStrip() {
            // å¯†åº¦è°ƒæ•´ï¼šå¢åŠ æ•°é‡åˆ°1500ï¼Œç¡®ä¿è½®å»“æ¸…æ™°
            const stripLightsCount = 1500; 
            const geometry = new THREE.SphereGeometry(0.12, 8, 8); // å°ºå¯¸å‡å°åˆ° 0.12ï¼Œæ›´åƒç²¾è‡´çš„å°ç¯ç 
            
            const material = new THREE.MeshStandardMaterial({
                color: 0xFFFFE0, // Light Yellow
                emissive: 0xFFD700,
                emissiveIntensity: 1.5,
                roughness: 0.2,
                metalness: 0.5,
                toneMapped: false
            });

            for (let i = 0; i < stripLightsCount; i++) {
                // 0 (top) -> 1 (bottom)
                const t = i / stripLightsCount;
                
                // Spiral logic for TREE state (Still needed for default state)
                const turns = 10;
                const angle = t * turns * Math.PI * 2;
                const heightRange = CONFIG.height;
                const y = (heightRange / 2) - (t * heightRange); // Top down
                const r = (t * CONFIG.radius) + 1.0; 
                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);
                const treePos = new THREE.Vector3(x, y, z);

                // Explode Position
                const explodePos = getExplodeSpherePosition(35);

                // --- Heart Contour Logic (Neon Edge) ---
                // tParam: 0 to 2PI (Full loop)
                const tParam = t * Math.PI * 2; 
                
                // Scale factor
                const s = 1.0; 
                // 2D Profile (Outline only)
                const hx = 16 * Math.pow(Math.sin(tParam), 3) * s;
                const hy = (13 * Math.cos(tParam) - 5 * Math.cos(2*tParam) - 2 * Math.cos(3*tParam) - Math.cos(4*tParam)) * s + 5;
                // Z = 0 (or slightly front to pop out)
                const hz = 2; // Front edge
                
                const heartPos = new THREE.Vector3(hx, hy, hz);
                
                const mesh = new THREE.Mesh(geometry, material.clone()); 
                
                mesh.position.copy(treePos);
                scene.add(mesh);
                
                const pData = {
                    mesh: mesh,
                    treePos: treePos,
                    explodePos: explodePos,
                    heartPos: heartPos, // Highlighting the edge
                    velocity: new THREE.Vector3(),
                    wobbleOffset: Math.random() * 100,
                    isLight: true,
                    // ç¯å¸¦ç‰¹æœ‰çš„è·‘é©¬ç¯é—ªçƒæ•ˆæœ
                    blinkSpeed: 2.0, 
                    blinkOffset: i * 0.05 
                };
                
                particles.push(pData);
                twinkleLights.push(pData);
            }
        }

        function createParticles() {
            // 1. åŸºç¡€å‡ ä½•ä½“
            const geometrySphere = new THREE.SphereGeometry(0.4, 16, 16); 
            const geometryCube = new THREE.BoxGeometry(0.8, 0.8, 0.8); // æ ‘å¶
            const geometryTetra = new THREE.TetrahedronGeometry(0.6); // æ ‘å¶
            const geometrySmallBox = new THREE.BoxGeometry(0.5, 0.5, 0.5); // ç¤¼ç‰©ç›’
            const geometryCylinder = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8); // ç³–æœæ£’
            const geometryLight = new THREE.SphereGeometry(0.25, 16, 16); // ç¯æ³¡

            // 2. åŸºç¡€æè´¨
            const matGold = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, roughness: 0.2, metalness: 0.8, emissive: 0x443300 
            });
            const matRed = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, roughness: 0.3, metalness: 0.3, emissive: 0x220000
            });
            // Changed: Assign to global variable so we can tween color later
            matGreen = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, roughness: 0.8, metalness: 0.0 
            });
            const matWhite = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF, roughness: 0.2, metalness: 0.1
            });

            for (let i = 0; i < CONFIG.particles; i++) {
                let mesh;
                let isLight = false;
                let blinkSpeed = 0;
                let blinkOffset = 0;

                const type = Math.random();
                
                // --- ç²’å­ç±»å‹åˆ†å¸ƒ ---
                // 60% æ ‘å¶ (Cube/Tetrahedron)
                // 15% è£…é¥°çƒ (Sphere)
                // 10% ç‰¹æ®ŠæŒ‚ä»¶ (ç³–æœ/ç¤¼ç‰©)
                // 15% é—ªçƒç¯å…‰ (Light)

                if (type < 0.6) {
                    // æ ‘å¶
                    const isCube = Math.random() > 0.5;
                    mesh = new THREE.Mesh(isCube ? geometryCube : geometryTetra, matGreen);
                    mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                
                } else if (type < 0.75) {
                    // è£…é¥°çƒ (é‡‘/çº¢)
                    mesh = new THREE.Mesh(geometrySphere, Math.random() > 0.5 ? matGold : matRed);
                    mesh.scale.setScalar(1.2 + Math.random() * 0.5);
                
                } else if (type < 0.85) {
                    // ç‰¹æ®ŠæŒ‚ä»¶
                    if (Math.random() > 0.5) {
                        // ç³–æœæ£’ (çº¢ç™½é•¿æ¡)
                        mesh = new THREE.Mesh(geometryCylinder, matRed);
                        mesh.rotation.z = Math.PI / 4; // æ–œç€æ”¾
                    } else {
                        // ç¤¼ç‰©ç›’ (é‡‘è‰²/ç™½è‰²)
                        mesh = new THREE.Mesh(geometrySmallBox, Math.random() > 0.5 ? matGold : matWhite);
                        mesh.rotation.y = Math.random();
                    }
                
                } else {
                    // ğŸ’¡ é—ªçƒç¯å…‰ ğŸ’¡
                    isLight = true;
                    // éšæœºé€‰ä¸€ä¸ªé¢œè‰²
                    const colorHex = CONFIG.colors.lights[Math.floor(Math.random() * CONFIG.colors.lights.length)];
                    const lightMat = new THREE.MeshStandardMaterial({
                        color: colorHex,
                        emissive: colorHex,
                        emissiveIntensity: 2.0, // åˆå§‹äº®åº¦é«˜ä¸€ç‚¹
                        roughness: 0.1,
                        metalness: 0.0,
                        toneMapped: false // è®©å®ƒçœ‹èµ·æ¥æ›´äº®ï¼Œä¸è¢«å‹æš—
                    });
                    
                    mesh = new THREE.Mesh(geometryLight, lightMat);
                    blinkSpeed = 2 + Math.random() * 3; // é—ªçƒé€Ÿåº¦
                    blinkOffset = Math.random() * Math.PI * 2; // éšæœºç›¸ä½ï¼Œé¿å…åŒæ—¶é—ª
                }

                // Tree Position (Target) - ä½¿ç”¨ä½“ç§¯ç®—æ³•
                // ç¯å…‰å’ŒæŒ‚ä»¶ç¨å¾®å¾€å¤–æ”¾ä¸€ç‚¹ (pow 0.3 è€Œä¸æ˜¯ 0.4)
                const h = Math.random(); 
                const treePos = getConeVolumePosition(h, CONFIG.radius);
                
                if (isLight || type >= 0.6) {
                    // æŠŠè£…é¥°ç‰©ç¨å¾®å¾€å¤–æ¨ï¼Œé˜²æ­¢è¢«æ ‘å¶åŸ‹æ²¡
                    const center = new THREE.Vector3(0, treePos.y, 0);
                    const dir = new THREE.Vector3().subVectors(treePos, center).normalize();
                    treePos.add(dir.multiplyScalar(0.8));
                }

                // Explode Position (Target)
                const explodePos = getExplodeSpherePosition(35);
                // Heart Position (Target) - Use Volume fill
                const heartPos = getHeartVolumePosition();

                // Initial Pos
                mesh.position.copy(treePos);
                
                scene.add(mesh);

                const pData = {
                    mesh: mesh,
                    treePos: treePos,
                    explodePos: explodePos,
                    heartPos: heartPos,
                    velocity: new THREE.Vector3(),
                    wobbleOffset: Math.random() * 100,
                    isLight: isLight,
                    blinkSpeed: blinkSpeed,
                    blinkOffset: blinkOffset
                };

                particles.push(pData);
                if (isLight) twinkleLights.push(pData);
            }
        }

        function createStar() {
            // Simple Star on top
            const geometry = new THREE.OctahedronGeometry(1.5, 0);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFFFF00, // Bright Yellow
                emissive: 0xFFD700,
                emissiveIntensity: 2, // æé«˜æ˜Ÿæ˜Ÿäº®åº¦
                roughness: 0.2,
                metalness: 0.8,
                toneMapped: false
            });
            const star = new THREE.Mesh(geometry, material);
            star.position.set(0, CONFIG.height/2 + 2, 0);
            
            // Star is just a special particle
            scene.add(star);
            particles.push({
                mesh: star,
                treePos: new THREE.Vector3(0, CONFIG.height/2 + 2, 0),
                explodePos: new THREE.Vector3(0, 10, 0),
                heartPos: new THREE.Vector3(0, 10, 0), // Heart Center
                wobbleOffset: 0
            });
        }

        // --- Photo Upload & Cache Logic ---

        // æ¸…é™¤ç°æœ‰çš„ç…§ç‰‡ï¼ˆä»åœºæ™¯å’Œå†…å­˜ä¸­ï¼‰
        window.clearCachedPhotos = function() {
            // 1. Remove from scene and memory
            // We iterate backwards to remove safely
            for (let i = particles.length - 1; i >= 0; i--) {
                if (particles[i].isPhoto) {
                    scene.remove(particles[i].mesh);
                    if (particles[i].mesh.material.map) {
                        particles[i].mesh.material.map.dispose();
                    }
                    particles[i].mesh.material.dispose();
                    particles[i].mesh.geometry.dispose();
                    particles.splice(i, 1);
                }
            }
            photoMeshes = [];

            // 2. Clear LocalStorage
            try {
                localStorage.removeItem(CONFIG.cacheKey);
                console.log("Cache cleared");
            } catch (e) {
                console.error("Failed to clear cache", e);
            }
        };

        // å¤„ç†ç”¨æˆ·ä¸Šä¼ 
        window.handlePhotoUpload = async function(event) {
            const files = event.target.files;
            if (!files.length) return;

            // è¦†ç›–æ¨¡å¼ï¼šä¸Šä¼ æ–°ç…§ç‰‡å‰æ¸…é™¤æ—§çš„
            window.clearCachedPhotos();

            const imagePromises = Array.from(files).map(processFileToDataURL);
            
            try {
                // ç­‰å¾…æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæˆï¼ˆå‹ç¼© + è½¬Base64ï¼‰
                const base64Images = await Promise.all(imagePromises);
                
                // åˆ›å»º Mesh
                base64Images.forEach(imgData => {
                    const img = new Image();
                    img.src = imgData;
                    img.onload = () => createPhotoMesh(img);
                });

                // ä¿å­˜åˆ°ç¼“å­˜
                saveToCache(base64Images);

            } catch (err) {
                console.error("Error processing images:", err);
                alert("å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•");
            }

            // é‡ç½® input ä»¥ä¾¿å…è®¸é‡å¤ä¸Šä¼ ç›¸åŒæ–‡ä»¶
            event.target.value = '';
        };
        
        // æ–°å¢ï¼šåŠ è½½é»˜è®¤ç…§ç‰‡åŠŸèƒ½
        window.loadDefaultPhotos = function() {
            // Show Loading
            const loadingScreen = document.getElementById('loading');
            const loadingText = document.getElementById('loading-text');
            
            loadingText.innerText = "æ­£åœ¨åŠ è½½é»˜è®¤ç…§ç‰‡...";
            loadingScreen.style.display = 'flex';
            // Force reflow
            void loadingScreen.offsetWidth; 
            loadingScreen.style.opacity = '1';

            // Use setTimeout to allow UI to render the loading screen before processing starts
            setTimeout(() => {
                // 1. Clear existing
                window.clearCachedPhotos();

                // 2. Load
                const defaults = CONFIG.defaultPhotos;
                let loadedCount = 0;
                const total = defaults.length;

                console.log("Loading default photos...");
                
                if (total === 0) {
                      hideLoading();
                      return;
                }

                defaults.forEach(url => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous"; 
                    img.src = url;
                    
                    const onFinish = () => {
                        loadedCount++;
                        if (loadedCount >= total) {
                            hideLoading();
                        }
                    };

                    img.onload = () => {
                        // ğŸŸ¢ FIX: Resize image to prevent mobile crash (Memory Limit)
                        const MAX_SIZE = 512; // Lower limit for mobile stability
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > MAX_SIZE) {
                                height *= MAX_SIZE / width;
                                width = MAX_SIZE;
                            }
                        } else {
                            if (height > MAX_SIZE) {
                                width *= MAX_SIZE / height;
                                height = MAX_SIZE;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        // Use canvas as texture source instead of original heavy image
                        createPhotoMesh(canvas); 
                        onFinish();
                    };
                    img.onerror = () => {
                        console.warn("Failed to load default photo:", url);
                        onFinish();
                    };
                });
            }, 100);

            function hideLoading() {
                setTimeout(() => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        // Restore original text just in case
                        loadingText.innerText = "æ­£åœ¨åˆå§‹åŒ–è§†è§‰å¼•æ“ä¸AIæ¨¡å‹...";
                    }, 500);
                }, 800);
            }
        };

        // å°†æ–‡ä»¶è¯»å–å¹¶å‹ç¼©ä¸º Base64
        function processFileToDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        // åˆ›å»º Canvas è¿›è¡Œå‹ç¼©
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // æœ€å¤§å°ºå¯¸é™åˆ¶ (é¿å… localStorage çˆ†æ»¡)
                        const MAX_SIZE = 800; 
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > MAX_SIZE) {
                                height *= MAX_SIZE / width;
                                width = MAX_SIZE;
                            }
                        } else {
                            if (height > MAX_SIZE) {
                                width *= MAX_SIZE / height;
                                height = MAX_SIZE;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);

                        // è½¬æ¢ä¸º JPEG Base64 (0.8 è´¨é‡)
                        const dataURL = canvas.toDataURL('image/jpeg', 0.8);
                        resolve(dataURL);
                    };
                    img.onerror = reject;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // ä¿å­˜åˆ° LocalStorage
        function saveToCache(imagesData) {
            const cacheData = {
                timestamp: Date.now(),
                images: imagesData
            };
            try {
                localStorage.setItem(CONFIG.cacheKey, JSON.stringify(cacheData));
            } catch (e) {
                console.warn("Storage quota exceeded or error", e);
                alert("ç…§ç‰‡è¿‡å¤šæˆ–è¿‡å¤§ï¼Œéƒ¨åˆ†ç¼“å­˜å¯èƒ½å¤±è´¥");
            }
        }

        // åŠ è½½ç¼“å­˜
        function loadCachedPhotos() {
            try {
                const raw = localStorage.getItem(CONFIG.cacheKey);
                if (!raw) return;

                const cache = JSON.parse(raw);
                const now = Date.now();

                // æ£€æŸ¥æœ‰æ•ˆæœŸ (7å¤©)
                if (now - cache.timestamp > CONFIG.cacheDuration) {
                    console.log("Cache expired, clearing...");
                    localStorage.removeItem(CONFIG.cacheKey);
                    return;
                }

                if (cache.images && Array.isArray(cache.images)) {
                    console.log(`Loading ${cache.images.length} photos from cache...`);
                    cache.images.forEach(imgData => {
                        const img = new Image();
                        img.src = imgData;
                        img.onload = () => createPhotoMesh(img);
                    });
                }
            } catch (e) {
                console.error("Failed to load cache", e);
            }
        }

        function createPhotoMesh(image) {
            const texture = new THREE.Texture(image);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;

            // Maintain aspect ratio
            const aspect = image.width / image.height;
            const w = 4;
            const h = 4 / aspect;

            const geometry = new THREE.PlaneGeometry(w, h);
            // Use BasicMaterial for photos so they are always fully bright and not affected by shadows
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0 
            });

            const mesh = new THREE.Mesh(geometry, material);
            
            // Add a border (gold frame)
            const frameGeo = new THREE.BoxGeometry(w + 0.2, h + 0.2, 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                metalness: 0.8, 
                roughness: 0.2,
                emissive: 0x332200
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.z = -0.06;
            mesh.add(frame);

            // ä¿®æ”¹ä½ç½®è®¡ç®—é€»è¾‘ï¼šä½¿ç”¨ç¡®å®šæ€§çš„é»„é‡‘èºæ—‹ç®—æ³•
            // ä¼ å…¥å½“å‰ç…§ç‰‡çš„æ€»æ•°ä½œä¸º indexï¼Œç¡®ä¿æ¯å¼ æ–°ç…§ç‰‡éƒ½æœ‰å”¯ä¸€ä¸”å‡åŒ€çš„ä½ç½®
            const index = photoMeshes.length;
            const treePos = getPhotoSurfacePosition(index);

            // Explode Position (Target) - ä¿®æ”¹ä¸ºçƒä½“åˆ†å¸ƒ
            const explodePos = getExplodeSpherePosition(35);
            // Heart Position
            const heartPos = getHeartVolumePosition();

            mesh.position.copy(explodePos); // Start exploded if added later, or logic will fix it
            scene.add(mesh);

            photoMeshes.push({
                mesh: mesh,
                treePos: treePos,
                explodePos: explodePos,
                heartPos: heartPos,
                wobbleOffset: Math.random() * 100,
                isPhoto: true
            });
            
            // Add to main particles array for movement management
            particles.push(photoMeshes[photoMeshes.length-1]);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 1. Smooth State Transition
            if (currentState !== targetState) {
                currentState = targetState;
                
                // If entering focus mode, pick a random photo to bring forward if any exist
                if (currentState === STATE.FOCUS && photoMeshes.length > 0) {
                      // Reset all photos first
                      photoMeshes.forEach(p => p.focusOffset = null);
                      // Pick one
                      const luckyPhoto = photoMeshes[Math.floor(Math.random() * photoMeshes.length)];
                      luckyPhoto.focusOffset = true;
                }
            }

            // --- æ–°å¢ï¼šé¢œè‰²è¿‡æ¸¡é€»è¾‘ ---
            if (matGreen) {
                // å¦‚æœæ˜¯å¿ƒåŠ¨æ¨¡å¼ï¼Œç›®æ ‡é¢œè‰²ä¸ºæµªæ¼«ç²‰çº¢/çº¢ï¼›å¦åˆ™ä¸ºæ£®æ—ç»¿
                const targetColorHex = (currentState === STATE.HEART) ? CONFIG.colors.heartRed : CONFIG.colors.green;
                const targetColor = new THREE.Color(targetColorHex);
                
                // å¹³æ»‘è¿‡æ¸¡é¢œè‰² (0.05 é€Ÿåº¦)
                matGreen.color.lerp(targetColor, 0.05);

                // å¾®å…‰æ•ˆæœï¼šå¿ƒåŠ¨æ¨¡å¼ä¸‹å¢åŠ ä¸€ç‚¹è‡ªå‘å…‰
                const targetEmissive = (currentState === STATE.HEART) ? new THREE.Color(0x330011) : new THREE.Color(0x000000);
                matGreen.emissive.lerp(targetEmissive, 0.05);
            }

            // 2. Camera Controls
            let camX = Math.sin(time * 0.2) * 50;
            let camZ = Math.cos(time * 0.2) * 50;
            let camY = 0;

            // Hand Influence
            if (currentState === STATE.EXPLODE && isHandDetected) {
                const angle = handPos.x * Math.PI; 
                camX = Math.sin(angle) * 60;
                camZ = Math.cos(angle) * 60;
                camY = handPos.y * 30;
            } else if (currentState === STATE.FOCUS) {
                camX *= 0.3;
                camZ *= 0.3;
            }

            camera.position.x += (camX - camera.position.x) * 0.05;
            camera.position.y += (camY - camera.position.y) * 0.05;
            camera.position.z += (camZ - camera.position.z) * 0.05;
            camera.lookAt(0, 0, 0);

            // 3. Update Visual Effects (Snow, Dust)
            
            // Snow
            if (snowParticles) {
                const positions = snowParticles.geometry.attributes.position.array;
                const vels = snowParticles.userData.velocities;
                for (let i=0; i<vels.length; i++) {
                    const i3 = i*3;
                    positions[i3+1] -= vels[i]; // Fall down
                    // Reset if too low
                    if (positions[i3+1] < -20) {
                        positions[i3+1] = 40;
                        positions[i3] = (Math.random() - 0.5) * 80;
                        positions[i3+2] = (Math.random() - 0.5) * 80;
                    }
                }
                snowParticles.geometry.attributes.position.needsUpdate = true;
            }
            
            // Magic Dust (Rotate)
            if (magicDust) {
                magicDust.rotation.y = time * 0.05;
            }

            // 4. Particle Animation & Twinkle
            
            // A. Update Lights (Twinkle Effect)
            // æ— è®ºæ˜¯åˆæ‹¢è¿˜æ˜¯æ•£å¼€ï¼Œç¯å…‰éƒ½ä¼šé—ªçƒ
            twinkleLights.forEach(p => {
                // ä½¿ç”¨æ­£å¼¦æ³¢æ§åˆ¶å‘å…‰å¼ºåº¦ï¼šåŸºå‡† 1.0 + æ³¢åŠ¨ 1.0 = èŒƒå›´ [0, 2.0]
                const intensity = 1.0 + Math.sin(time * p.blinkSpeed + p.blinkOffset) * 1.0;
                // ä¿è¯æœ€ä½äº®åº¦ä¸ä¸º0ï¼Œé¿å…å®Œå…¨é»‘æ‰
                p.mesh.material.emissiveIntensity = Math.max(0.2, intensity);
            });

            // B. Move Particles
            particles.forEach(p => {
                let target;

                if (currentState === STATE.TREE) {
                    target = p.treePos;
                } else if (currentState === STATE.EXPLODE) {
                    target = p.explodePos;
                } else if (currentState === STATE.HEART) {
                    // Heart Beat Logic
                    // We need to pulse the heart.
                    // Heart Center is approx 0, 5, 0
                    const center = new THREE.Vector3(0, 5, 0);
                    // Beat rhythm: fast sharp beat
                    const beat = 1 + 0.15 * Math.pow(Math.sin(time * 5), 3);
                    
                    const rawTarget = p.heartPos.clone();
                    const dir = rawTarget.sub(center);
                    target = center.clone().add(dir.multiplyScalar(beat));
                    
                } else if (currentState === STATE.FOCUS) {
                    target = p.explodePos; 
                    
                    if (p.focusOffset) {
                        const camDir = camera.position.clone().normalize();
                        const targetPos = camDir.multiplyScalar(10);
                        p.mesh.position.lerp(targetPos, 0.1);
                        p.mesh.quaternion.copy(camera.quaternion);
                        return; // Skip standard update
                    }
                }

                const wobble = Math.sin(time * 2 + p.wobbleOffset) * 0.5;
                const finalTarget = target.clone();
                if (currentState !== STATE.TREE) {
                    finalTarget.y += wobble;
                }

                // Move mesh
                p.mesh.position.lerp(finalTarget, 0.04);
                
                // Rotation
                if (!p.isPhoto) {
                    // è£…é¥°ç‰©ç¼“æ…¢è‡ªè½¬
                    p.mesh.rotation.x += 0.01;
                    p.mesh.rotation.y += 0.01;
                } else if (currentState === STATE.TREE) {
                    p.mesh.lookAt(new THREE.Vector3(p.mesh.position.x * 2, p.mesh.position.y, p.mesh.position.z * 2));
                } else {
                    p.mesh.quaternion.copy(camera.quaternion);
                }
            });

            // æ™®é€šæ¸²æŸ“
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();

    </script>
</body>
</html>