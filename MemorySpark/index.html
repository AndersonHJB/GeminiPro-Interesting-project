<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MemorySparkï½œai.bornforthis.cn AIå®éªŒå®¤</title>
    <link rel="icon" href="https://bornforthis.cn/favicon.ico">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111; /* ç¨å¾®æäº®ä¸€ç‚¹ç‚¹èƒŒæ™¯ï¼Œä¸æ˜¯çº¯é»‘ */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            text-align: left;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        h1 {
            margin: 0;
            font-weight: 300;
            color: #FFD700; /* Gold */
            letter-spacing: 2px;
            font-size: 24px;
        }

        p.subtitle {
            margin: 5px 0 0 0;
            color: #aaa;
            font-size: 14px;
        }

        /* Status & Instructions & Buttons Container */
        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Right align everything */
            gap: 12px;
        }

        .status-tag {
            display: inline-block;
            padding: 8px 16px;
            background: rgba(20, 30, 20, 0.8);
            border: 1px solid #FFD700;
            border-radius: 20px;
            color: #FFD700;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        .instructions {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px; /* Slightly squarer for tech feel */
            font-size: 12px;
            color: #ddd;
            width: 200px; /* Fixed width for alignment */
            pointer-events: auto;
            backdrop-filter: blur(10px);
            border-left: 2px solid #C41E3A; /* Red accent */
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .instruction-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            justify-content: space-between; /* Space out icon and text */
        }
        
        .icon { font-size: 16px; width: 20px; text-align: center;}

        /* Upload Buttons - New Elegant Style */
        .upload-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
            margin-top: 5px;
            width: 220px; /* Give it a bit more width for the dropdown */
        }

        .btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 215, 0, 0.5); /* Subtle Gold Border */
            color: #FFD700;
            padding: 8px 20px;
            border-radius: 4px; /* Minimalist radius */
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
            width: 100%; /* Match width */
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-sizing: border-box; /* Ensure padding doesn't increase width */
        }

        .btn:hover {
            background: rgba(255, 215, 0, 0.15);
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            transform: translateX(-5px); /* Subtle slide left */
        }

        .btn.active {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
            border-color: #FFD700;
        }

        /* Group music buttons slightly */
        .music-group {
            display: flex;
            gap: 5px;
            width: 100%;
        }
        
        .music-group .btn {
            flex: 1; /* Split space */
            padding: 8px 5px; /* Smaller padding */
        }
        
        #music-btn {
            flex: 0 0 40%; /* Play button takes less space */
        }
        
        #playlist-select {
            flex: 1;
            appearance: none; /* Remove default arrow */
            -webkit-appearance: none;
            text-align: left;
            text-align-last: center;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23FFD700' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 12px;
            padding-right: 25px; /* Space for arrow */
            padding-left: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #FFD700;
        }
        
        #playlist-select option {
            background: #222;
            color: #FFD700;
            padding: 5px;
        }

        /* Differentiate clear button slightly */
        #clear-btn {
            border-color: rgba(255, 255, 255, 0.3);
            color: #aaa;
        }
        
        #clear-btn:hover {
            border-color: #fff;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        #file-input { display: none; }
        #music-input { display: none; }

        /* Webcam feedback (hidden but processed) */
        #video-feed {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            transform: scaleX(-1); /* Mirror */
            border: 2px solid #FFD700;
            opacity: 0.7;
            z-index: 20;
            object-fit: cover;
            display: block; /* Required for MediaPipe */
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #FFD700;
            transition: opacity 0.5s;
        }

        .loader {
            border: 4px solid #333;
            border-top: 4px solid #FFD700;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
    <!-- MediaPipe Hands Global Script (Fix for Module Error) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

    <!-- Import Maps for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- Audio Element -->
    <audio id="bg-music" loop>
        <source src="https://cdn.bornforthis.cn/mp3/LastChristmas(Single%20Version).m4a" type="audio/mp4">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
    </audio>

    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader"></div>
        <div id="loading-text">æ­£åœ¨åˆå§‹åŒ–è§†è§‰å¼•æ“ä¸AIæ¨¡å‹...</div>
    </div>

    <!-- Video Element for MediaPipe (Visible for user feedback) -->
    <video id="video-feed" playsinline></video>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="header">
            <h1>åœ£è¯èŠ‚ğŸ„å¿«ä¹ï¼ï½œBornforthis AIå®éªŒå®¤</h1>
            <p class="subtitle">https://ai.bornforthis.cn/</p>
        </div>

        <div class="status-panel">
            <div id="mode-display" class="status-tag">ç­‰å¾…æ‰‹åŠ¿...</div>
            
            <div class="instructions">
                <div class="instruction-item"><span>âœŠ æ¡æ‹³</span> <span>èšåˆå½¢æ€</span></div>
                <div class="instruction-item"><span>ğŸ– å¼ å¼€</span> <span>æ•£å¼€å½¢æ€</span></div>
                <div class="instruction-item"><span>ğŸ¤ æåˆ</span> <span>ç‰¹å†™ç…§ç‰‡</span></div>
                <div class="instruction-item"><span>ğŸ‘‹ ç§»åŠ¨</span> <span>æ—‹è½¬è§†è§’</span></div>
            </div>

            <div class="upload-container">
                <button id="upload-btn" class="btn" onclick="document.getElementById('file-input').click()">
                    <span>ğŸ“·</span> ä¸Šä¼ ç…§ç‰‡
                </button>
                
                <div class="music-group">
                    <button id="music-btn" class="btn" onclick="toggleMusic()">
                        <span>ğŸ”‡</span>
                    </button>
                    <!-- ä¸‹æ‹‰é€‰æ‹©æ¡†æ›¿ä»£åŸæ¥çš„â€œæ¢éŸ³ä¹â€æŒ‰é’® -->
                    <select id="playlist-select" class="btn" onchange="handlePlaylistChange(this)">
                        <option disabled>-- é€‰æ‹©èƒŒæ™¯éŸ³ä¹ --</option>
                        <!-- Options will be populated by JS -->
                        <option value="custom">ğŸ“‚ è‡ªå®šä¹‰...</option>
                    </select>
                </div>

                <button id="clear-btn" class="btn" onclick="clearCachedPhotos()">
                    <span>ğŸ—‘ï¸</span> æ¸…é™¤ç…§ç‰‡
                </button>
                
                <input type="file" id="file-input" accept="image/*" multiple onchange="handlePhotoUpload(event)">
                <!-- æ–°å¢éŸ³ä¹æ–‡ä»¶è¾“å…¥æ¡† -->
                <input type="file" id="music-input" accept="audio/*, .mp3, .m4a" onchange="handleMusicFileUpload(event)">
            </div>
        </div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';

        // --- Configuration & Constants ---
        const CONFIG = {
            colors: {
                green: 0x228B22,   // Forest Green (Brighter)
                gold: 0xFFD700,    // Metallic Gold
                red: 0xFF0000,     // Bright Red
                white: 0xFFFFFF
            },
            particles: 1500,       // å¢åŠ ç²’å­æ•°é‡åˆ° 1500ï¼Œè®©æ ‘æ›´èŒ‚å¯†
            radius: 18,            // Base radius of tree bottom
            height: 35,            // Height of tree
            cacheKey: 'xmas_tree_photos_v1',
            cacheDuration: 7 * 24 * 60 * 60 * 1000, // 7 Days in ms
            musicCacheKey: 'xmas_music_pref_v3', // æ›´æ–°ç‰ˆæœ¬å·ä»¥é€‚åº”æ–°é€»è¾‘
            
            // å†…ç½®æ­Œå•
            playlist: [
                { name: "Last Christmas", url: "https://cdn.bornforthis.cn/mp3/LastChristmas(Single%20Version).m4a" },
                { name: "Jingle Bell Rock", url: "https://cdn.bornforthis.cn/mp3/JingleBellRock.m4a" },
                { name: "Santa Tell Me", url: "https://cdn.bornforthis.cn/mp3/SantaTellMe.m4a" },
                { name: "Feliz Navidad", url: "https://cdn.bornforthis.cn/mp3/FelizNavidad.m4a" },
                { name: "Santa Claus is Coming", url: "https://cdn.bornforthis.cn/mp3/SantaClausisComingtoTown.m4a" },
                { name: "Here Comes Santa Claus", url: "https://cdn.bornforthis.cn/mp3/HereComesSantaClaus.m4a" },
                { name: "Merry Christmas Mr Lawrence", url: "https://cdn.bornforthis.cn/mp3/MerryChristmasMrLawrence.m4a" },
                { name: "Christmas Time in My Town", url: "https://cdn.bornforthis.cn/mp3/ChristmasTimeinMyHomeTown.mp3" },
            ]
        };

        // --- Global Variables ---
        let scene, camera, renderer;
        let particles = []; // Array to store { mesh, treePos, explodePos, currentPos, speed }
        let photoMeshes = []; // Array specifically for user photos
        let time = 0;
        
        // Interaction State
        const STATE = {
            TREE: 'TREE',
            EXPLODE: 'EXPLODE',
            FOCUS: 'FOCUS'
        };
        let currentState = STATE.TREE;
        let targetState = STATE.TREE;
        
        // Hand Data
        let handPos = { x: 0, y: 0 }; // Normalized -1 to 1
        let isHandDetected = false;

        // Music State
        let isMusicPlaying = false;
        let currentMusicSource = CONFIG.playlist[0].url; // Default to first song

        // --- Initialization ---
        async function init() {
            // 1. Scene Setup
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); // Dark Gray instead of pure black

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            // 2. Lighting - å¤§å¹…å¢å¼ºå…‰ç…§
            // 2.1 å¼ºç¯å¢ƒå…‰ï¼Œç…§äº®æ‰€æœ‰é˜´å½±
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5); 
            scene.add(ambientLight);

            // 2.2 ä¸»å¹³è¡Œå…‰ï¼ˆæ¨¡æ‹Ÿé˜³å…‰ï¼‰ï¼Œæä¾›æ¸…æ™°çš„æ˜æš—å…³ç³»
            const mainLight = new THREE.DirectionalLight(0xffffff, 2.5);
            mainLight.position.set(10, 20, 20);
            scene.add(mainLight);

            // 2.3 è¡¥å…‰ç¯ï¼ˆé‡‘è‰²ï¼‰ï¼Œå¢åŠ åä¸½æ„Ÿ
            const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 100);
            pointLight.position.set(0, 20, 10);
            scene.add(pointLight);
            
            // 2.4 æ°›å›´ç¯ï¼ˆçº¢ç»¿ï¼‰ï¼Œå¢åŠ èŠ‚æ—¥æ°”æ°›ï¼Œä½†è°ƒé«˜äº®åº¦
            const redLight = new THREE.PointLight(CONFIG.colors.red, 2, 50);
            redLight.position.set(15, 10, 15);
            scene.add(redLight);
            
            const greenLight = new THREE.PointLight(CONFIG.colors.green, 2, 50);
            greenLight.position.set(-15, -10, 15);
            scene.add(greenLight);

            // 3. Post Processing Removed

            // 4. Content Generation
            createParticles();
            createStar();
            
            // 5. Load Cached Photos & Music Preference
            loadCachedPhotos();
            initAudio(); // åˆå§‹åŒ–éŸ³é¢‘å’Œä¸‹æ‹‰èœå•

            // 6. Setup MediaPipe
            await setupMediaPipe();

            // 7. Events
            window.addEventListener('resize', onWindowResize);

            // 8. Start Loop
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
            animate();
        }

        // --- Audio Logic ---
        
        function initAudio() {
            // 1. Populate Dropdown
            const select = document.getElementById('playlist-select');
            
            // Insert Built-in options BEFORE the "Custom" option
            CONFIG.playlist.forEach(song => {
                const option = document.createElement('option');
                option.value = song.url;
                option.innerText = `ğŸµ ${song.name}`;
                // Insert before the last option (which is Custom)
                select.insertBefore(option, select.lastElementChild);
            });

            // 2. Load Preferences
            const audio = document.getElementById('bg-music');
            
            try {
                const raw = localStorage.getItem(CONFIG.musicCacheKey);
                if (raw) {
                    const cache = JSON.parse(raw);
                    const now = Date.now();
                    
                    if (now - cache.timestamp <= CONFIG.cacheDuration) {
                        // æ¢å¤éŸ³ä¹æº
                        if (cache.customSrc) {
                            currentMusicSource = cache.customSrc;
                        }

                        // æ¢å¤æ’­æ”¾çŠ¶æ€
                        if (cache.enabled) {
                            isMusicPlaying = true;
                            // Play will be called below
                        }
                    }
                }
            } catch (e) {
                console.error("Error loading music preference", e);
            }

            // 3. Apply Source
            audio.src = currentMusicSource;
            
            // 4. Sync Dropdown Value
            // Check if current source is in playlist
            const inPlaylist = CONFIG.playlist.find(p => p.url === currentMusicSource);
            if (inPlaylist) {
                select.value = currentMusicSource;
            } else {
                // It's a custom source (or stale default), strictly we don't have a value for it in select unless we add one
                // For UI consistency, if it's custom data (blob/base64), we might just show "Custom" selected, but value='custom' triggers logic.
                // We'll leave it as is, or maybe add a hidden option for "Current Custom"
                // Simple hack: if it's not in playlist, assume custom logic handled by "Custom..." click
                // But let's verify if we can set it visually.
                // For now, if custom, we won't force select value, it might show "Select Music"
            }

            // 5. Play if needed
            updateMusicUI(isMusicPlaying);
            if (isMusicPlaying) {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log("Auto-play blocked.");
                        // Update UI to show paused since block
                        isMusicPlaying = false;
                        updateMusicUI(false);
                    });
                }
            }
        }

        // å¤„ç†ä¸‹æ‹‰èœå•å˜åŒ–
        window.handlePlaylistChange = function(selectElem) {
            const value = selectElem.value;
            
            if (value === 'custom') {
                // ç”¨æˆ·é€‰æ‹©â€œè‡ªå®šä¹‰â€
                handleCustomMusicClick();
                // æš‚æ—¶æŠŠé€‰ä¸­çš„å€¼é‡ç½®å›ä¹‹å‰çš„ï¼ˆæˆ–è€…ä¿æŒ Customï¼‰ï¼Œç­‰å¾…ç”¨æˆ·å®Œæˆä¸Šä¼ 
                // å®é™…ä¸Š handleCustomMusicClick ä¼šæ›´æ–°æº
            } else {
                // ç”¨æˆ·é€‰æ‹©äº†å†…ç½®æ­Œæ›²
                changeMusicSource(value, 'builtin');
            }
        };

        window.handleCustomMusicClick = function() {
            const url = prompt("è¯·è¾“å…¥èƒŒæ™¯éŸ³ä¹é“¾æ¥ (MP3/M4A)\næˆ–è€…ç‚¹å‡» [å–æ¶ˆ] ä¸Šä¼ æœ¬åœ°æ–‡ä»¶:");
            
            if (url) {
                changeMusicSource(url.trim(), 'link');
            } else if (url === "") {
                // Cancelled or empty
                // Revert selection if possible?
            } else {
                // Clicked Cancel -> File Upload
                document.getElementById('music-input').click();
            }
        };

        window.handleMusicFileUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const result = e.target.result;
                const canCache = result.length < 4 * 1024 * 1024; 
                changeMusicSource(result, 'file', canCache);
                if (!canCache) {
                    alert("éŸ³ä¹æ–‡ä»¶è¾ƒå¤§ï¼Œä»…åœ¨æœ¬æ¬¡è®¿é—®æ’­æ”¾ï¼Œä¸ä¼šç¼“å­˜åˆ°æœ¬åœ°ã€‚");
                }
            };
            reader.readAsDataURL(file);
            event.target.value = ''; 
        };

        function changeMusicSource(src, type, shouldCache = true) {
            const audio = document.getElementById('bg-music');
            currentMusicSource = src;
            audio.src = src;
            
            // Auto play
            isMusicPlaying = true;
            audio.play().catch(e => console.log("Play interrupted", e));
            updateMusicUI(true);
            
            // Update Dropdown UI to reflect change
            const select = document.getElementById('playlist-select');
            // If it's a built-in type, select matches src
            if (type === 'builtin') {
                 select.value = src;
            } else {
                // If custom, we want the dropdown to show something indicating custom?
                // The 'custom' option value is "custom", but that triggers the prompt.
                // We'll just leave it; the user hears the music.
            }
            
            // Save
            saveMusicPreference(true, shouldCache ? src : null);
        }

        window.toggleMusic = function() {
            const audio = document.getElementById('bg-music');
            isMusicPlaying = !isMusicPlaying;
            
            if (isMusicPlaying) {
                audio.play();
            } else {
                audio.pause();
            }
            
            updateMusicUI(isMusicPlaying);
            // Save state (keep existing src)
            saveMusicPreference(isMusicPlaying, null, true); 
        };

        function updateMusicUI(isPlaying) {
            const btn = document.getElementById('music-btn');
            if (isPlaying) {
                btn.innerHTML = '<span>ğŸ”Š</span>';
                btn.classList.add('active');
            } else {
                btn.innerHTML = '<span>ğŸ”‡</span>';
                btn.classList.remove('active');
            }
        }

        // srcData: å¦‚æœä¸ä¸º nullï¼Œåˆ™æ›´æ–° customSrcï¼›å¦‚æœä¸º null ä¸” updateOnlyState=falseï¼Œåˆ™æ¸…é™¤ customSrc
        // updateOnlyState: å¦‚æœä¸º trueï¼Œåªæ›´æ–°å¼€å…³çŠ¶æ€ï¼Œä¸ç¢° source
        function saveMusicPreference(isEnabled, srcData = null, updateOnlyState = false) {
            try {
                let dataToSave = {
                    timestamp: Date.now(),
                    enabled: isEnabled,
                    customSrc: null
                };

                if (updateOnlyState) {
                    const oldRaw = localStorage.getItem(CONFIG.musicCacheKey);
                    if (oldRaw) {
                        const old = JSON.parse(oldRaw);
                        dataToSave.customSrc = old.customSrc;
                    }
                } else {
                    dataToSave.customSrc = srcData;
                }

                localStorage.setItem(CONFIG.musicCacheKey, JSON.stringify(dataToSave));
            } catch (e) {
                console.warn("Failed to save music preference", e);
                // Fallback: save disabled state without source
                try {
                     const fallbackData = {
                        timestamp: Date.now(),
                        enabled: isEnabled,
                        customSrc: null 
                    };
                    localStorage.setItem(CONFIG.musicCacheKey, JSON.stringify(fallbackData));
                } catch(e2) {}
            }
        }

        // --- Particle System Logic ---

        // ç§»é™¤æ—§çš„èºæ—‹çº¿é€»è¾‘ï¼Œæ”¹ç”¨ä½“ç§¯è®¡ç®—
        function getConeVolumePosition(h, maxR) {
            // h is 0 (bottom) to 1 (top)
            
            // å½“å‰é«˜åº¦çš„åœ†é”¥æˆªé¢åŠå¾„
            const rAtHeight = maxR * (1 - h);
            
            // éšæœºåˆ†å¸ƒåœ¨åœ†æˆªé¢å†…ï¼Œä½†æ›´å€¾å‘äºå¤–è¡¨é¢ä»¥ä¿æŒæ ‘çš„å½¢çŠ¶
            // ä½¿ç”¨ Math.pow è°ƒæ•´åˆ†å¸ƒï¼šæŒ‡æ•°è¶Šå°è¶Šå‡åŒ€ï¼ŒæŒ‡æ•°è¶Šå¤§è¶Šé›†ä¸­åœ¨è¾¹ç¼˜
            const r = rAtHeight * Math.pow(Math.random(), 0.4); 
            
            const angle = Math.random() * Math.PI * 2;
            
            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);
            
            // å°†é«˜åº¦æ˜ å°„åˆ°å®é™…åæ ‡ y
            const y = -CONFIG.height/2 + h * CONFIG.height;
            
            return new THREE.Vector3(x, y, z);
        }

        // æ–°å¢ï¼šä¸“é—¨ç”¨äºæ•£å¼€å½¢æ€çš„çƒä½“åˆ†å¸ƒç®—æ³• (åœ†å½¢)
        function getExplodeSpherePosition(maxRadius) {
            // çƒåæ ‡éšæœºåˆ†å¸ƒ
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            
            // ä½¿ç”¨ç«‹æ–¹æ ¹ç¡®ä¿åœ¨ä½“ç§¯å†…å‡åŒ€åˆ†å¸ƒï¼ˆä¸ä»…ä»…æ˜¯è¡¨é¢ï¼Œä¹Ÿä¸ä»…ä»…æ˜¯æ ¸å¿ƒï¼‰
            const r = maxRadius * Math.cbrt(Math.random()); 
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            return new THREE.Vector3(x, y, z);
        }

        // æ–°å¢ï¼šä¸“é—¨ç”¨äºç…§ç‰‡çš„å‡åŒ€åˆ†å¸ƒç®—æ³• (åŸºäºé»„é‡‘è§’åº¦èºæ—‹)
        // è¿™èƒ½ç¡®ä¿æ— è®ºä¸Šä¼ å¤šå°‘å¼ ç…§ç‰‡ï¼Œå®ƒä»¬éƒ½èƒ½å‡åŒ€åœ°åˆ†å¸ƒåœ¨æ ‘çš„è¡¨é¢ï¼Œä¸ä¼šæ‰å †
        function getPhotoSurfacePosition(index) {
            // é»„é‡‘åˆ†å‰²æ¯”ï¼Œç”¨äºæ‰“æ•£é«˜åº¦å’Œè§’åº¦
            const goldenRatio = 0.61803398875;
            
            // é«˜åº¦åˆ†å¸ƒç®—æ³•ï¼š
            // ä½¿ç”¨ index * goldenRatio å–æ¨¡ï¼Œå¾—åˆ°ä¸€ä¸ªåœ¨ 0-1 ä¹‹é—´å‡åŒ€è·³è·ƒçš„ä¼ªéšæœºåºåˆ—
            // æˆ‘ä»¬é™åˆ¶èŒƒå›´åœ¨ 0.15 ~ 0.85 ä¹‹é—´ï¼Œé¿å…ç…§ç‰‡å‡ºç°åœ¨æ ‘å°–å¤ªé«˜æˆ–æ ‘åº•å¤ªä½çš„ä½ç½®
            const h = ((index * goldenRatio) % 0.7) + 0.15; 
            
            // è§’åº¦åˆ†å¸ƒï¼šé»„é‡‘è§’åº¦ (çº¦ 137.5 åº¦)
            // ä¿è¯ä»»æ„ç›¸é‚»æˆ–ç›¸è¿‘çš„ç…§ç‰‡åœ¨æ°´å¹³æ–¹å‘ä¸Šéƒ½ç›¸éš”ç”šè¿œï¼Œ360åº¦æ— æ­»è§’è¦†ç›–
            const angle = index * Math.PI * 2 * goldenRatio;
            
            // åŠå¾„è®¡ç®—ï¼šåŸºäºåœ†é”¥è¡¨é¢
            // CONFIG.radius æ˜¯åº•éƒ¨åŠå¾„
            const rBase = CONFIG.radius * (1 - h);
            const r = rBase + 2.5; // +2.5 è®©ç…§ç‰‡æ˜æ˜¾æ‚¬æµ®åœ¨æ ‘å¶è¡¨é¢ä¹‹å¤–ï¼Œä½œä¸ºè£…é¥°é‡ç‚¹
            
            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);
            const y = -CONFIG.height/2 + h * CONFIG.height;
            
            return new THREE.Vector3(x, y, z);
        }

        function createParticles() {
            const geometrySphere = new THREE.SphereGeometry(0.4, 32, 32); 
            const geometryCube = new THREE.BoxGeometry(0.8, 0.8, 0.8); // ç¨å¾®åŠ å¤§æ–¹å—ï¼Œå……å½“æ ‘å¶
            const geometryTetra = new THREE.TetrahedronGeometry(0.6); // å¢åŠ å››é¢ä½“ä½œä¸ºå¦ä¸€ç§æ ‘å¶
            
            // Materials - æ›´äº®ã€æ›´é²œè‰³çš„æè´¨è®¾ç½®
            const matGold = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                roughness: 0.2, 
                metalness: 0.6, 
                emissive: 0x443300 
            });
            const matRed = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, 
                roughness: 0.3, 
                metalness: 0.3, 
                emissive: 0x330000
            });
            const matGreen = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, 
                roughness: 0.8, // å“‘å…‰ï¼Œåƒå¶å­
                metalness: 0.0 
            });

            for (let i = 0; i < CONFIG.particles; i++) {
                let mesh;
                const type = Math.random();
                
                // è°ƒæ•´æ¯”ä¾‹ï¼š80% æ˜¯ç»¿è‰²æå¶ï¼Œ20% æ˜¯è£…é¥°å“
                if (type < 0.6) {
                    // Green filler (Box - æ ‘å¶)
                    mesh = new THREE.Mesh(geometryCube, matGreen);
                    mesh.rotation.set(Math.random(), Math.random(), Math.random());
                } else if (type < 0.8) {
                     // Green filler 2 (Tetrahedron - é’ˆå¶è´¨æ„Ÿ)
                    mesh = new THREE.Mesh(geometryTetra, matGreen);
                    mesh.rotation.set(Math.random(), Math.random(), Math.random());
                } else if (type < 0.9) {
                    // Gold ornaments (Sphere)
                    mesh = new THREE.Mesh(geometrySphere, matGold);
                    mesh.scale.setScalar(1.5);
                } else {
                    // Red ornaments (Sphere)
                    mesh = new THREE.Mesh(geometrySphere, matRed);
                    mesh.scale.setScalar(1.2);
                }

                // Tree Position (Target) - ä½¿ç”¨æ–°çš„ä½“ç§¯å¡«å……ç®—æ³•
                const h = Math.random(); // 0 åˆ° 1 çš„éšæœºé«˜åº¦
                const treePos = getConeVolumePosition(h, CONFIG.radius);

                // Explode Position (Target) - ä¿®æ”¹ä¸ºçƒä½“åˆ†å¸ƒ
                const explodePos = getExplodeSpherePosition(35);

                // Initial Pos
                mesh.position.copy(treePos);
                
                scene.add(mesh);

                particles.push({
                    mesh: mesh,
                    treePos: treePos,
                    explodePos: explodePos,
                    velocity: new THREE.Vector3(),
                    wobbleOffset: Math.random() * 100
                });
            }
        }

        function createStar() {
            // Simple Star on top
            const geometry = new THREE.OctahedronGeometry(1.5, 0);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFFFF00, // Bright Yellow
                emissive: 0xFFD700,
                emissiveIntensity: 1, // Reduced slightly as bloom is gone, but still bright
                roughness: 0.2,
                metalness: 0.8
            });
            const star = new THREE.Mesh(geometry, material);
            star.position.set(0, CONFIG.height/2 + 2, 0);
            
            // Star is just a special particle
            scene.add(star);
            particles.push({
                mesh: star,
                treePos: new THREE.Vector3(0, CONFIG.height/2 + 2, 0),
                explodePos: new THREE.Vector3(0, 10, 0),
                wobbleOffset: 0
            });
        }

        // --- Photo Upload & Cache Logic ---

        // æ¸…é™¤ç°æœ‰çš„ç…§ç‰‡ï¼ˆä»åœºæ™¯å’Œå†…å­˜ä¸­ï¼‰
        window.clearCachedPhotos = function() {
            // 1. Remove from scene and memory
            // We iterate backwards to remove safely
            for (let i = particles.length - 1; i >= 0; i--) {
                if (particles[i].isPhoto) {
                    scene.remove(particles[i].mesh);
                    if (particles[i].mesh.material.map) {
                        particles[i].mesh.material.map.dispose();
                    }
                    particles[i].mesh.material.dispose();
                    particles[i].mesh.geometry.dispose();
                    particles.splice(i, 1);
                }
            }
            photoMeshes = [];

            // 2. Clear LocalStorage
            try {
                localStorage.removeItem(CONFIG.cacheKey);
                console.log("Cache cleared");
            } catch (e) {
                console.error("Failed to clear cache", e);
            }
        };

        // å¤„ç†ç”¨æˆ·ä¸Šä¼ 
        window.handlePhotoUpload = async function(event) {
            const files = event.target.files;
            if (!files.length) return;

            // è¦†ç›–æ¨¡å¼ï¼šä¸Šä¼ æ–°ç…§ç‰‡å‰æ¸…é™¤æ—§çš„
            window.clearCachedPhotos();

            const imagePromises = Array.from(files).map(processFileToDataURL);
            
            try {
                // ç­‰å¾…æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæˆï¼ˆå‹ç¼© + è½¬Base64ï¼‰
                const base64Images = await Promise.all(imagePromises);
                
                // åˆ›å»º Mesh
                base64Images.forEach(imgData => {
                    const img = new Image();
                    img.src = imgData;
                    img.onload = () => createPhotoMesh(img);
                });

                // ä¿å­˜åˆ°ç¼“å­˜
                saveToCache(base64Images);

            } catch (err) {
                console.error("Error processing images:", err);
                alert("å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•");
            }

            // é‡ç½® input ä»¥ä¾¿å…è®¸é‡å¤ä¸Šä¼ ç›¸åŒæ–‡ä»¶
            event.target.value = '';
        };

        // å°†æ–‡ä»¶è¯»å–å¹¶å‹ç¼©ä¸º Base64
        function processFileToDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        // åˆ›å»º Canvas è¿›è¡Œå‹ç¼©
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // æœ€å¤§å°ºå¯¸é™åˆ¶ (é¿å… localStorage çˆ†æ»¡)
                        const MAX_SIZE = 800; 
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > MAX_SIZE) {
                                height *= MAX_SIZE / width;
                                width = MAX_SIZE;
                            }
                        } else {
                            if (height > MAX_SIZE) {
                                width *= MAX_SIZE / height;
                                height = MAX_SIZE;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);

                        // è½¬æ¢ä¸º JPEG Base64 (0.8 è´¨é‡)
                        const dataURL = canvas.toDataURL('image/jpeg', 0.8);
                        resolve(dataURL);
                    };
                    img.onerror = reject;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // ä¿å­˜åˆ° LocalStorage
        function saveToCache(imagesData) {
            const cacheData = {
                timestamp: Date.now(),
                images: imagesData
            };
            try {
                localStorage.setItem(CONFIG.cacheKey, JSON.stringify(cacheData));
            } catch (e) {
                console.warn("Storage quota exceeded or error", e);
                alert("ç…§ç‰‡è¿‡å¤šæˆ–è¿‡å¤§ï¼Œéƒ¨åˆ†ç¼“å­˜å¯èƒ½å¤±è´¥");
            }
        }

        // åŠ è½½ç¼“å­˜
        function loadCachedPhotos() {
            try {
                const raw = localStorage.getItem(CONFIG.cacheKey);
                if (!raw) return;

                const cache = JSON.parse(raw);
                const now = Date.now();

                // æ£€æŸ¥æœ‰æ•ˆæœŸ (7å¤©)
                if (now - cache.timestamp > CONFIG.cacheDuration) {
                    console.log("Cache expired, clearing...");
                    localStorage.removeItem(CONFIG.cacheKey);
                    return;
                }

                if (cache.images && Array.isArray(cache.images)) {
                    console.log(`Loading ${cache.images.length} photos from cache...`);
                    cache.images.forEach(imgData => {
                        const img = new Image();
                        img.src = imgData;
                        img.onload = () => createPhotoMesh(img);
                    });
                }
            } catch (e) {
                console.error("Failed to load cache", e);
            }
        }

        function createPhotoMesh(image) {
            const texture = new THREE.Texture(image);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;

            // Maintain aspect ratio
            const aspect = image.width / image.height;
            const w = 4;
            const h = 4 / aspect;

            const geometry = new THREE.PlaneGeometry(w, h);
            // Use BasicMaterial for photos so they are always fully bright and not affected by shadows
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0 
            });

            const mesh = new THREE.Mesh(geometry, material);
            
            // Add a border (gold frame)
            const frameGeo = new THREE.BoxGeometry(w + 0.2, h + 0.2, 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                metalness: 0.8, 
                roughness: 0.2,
                emissive: 0x332200
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.z = -0.06;
            mesh.add(frame);

            // ä¿®æ”¹ä½ç½®è®¡ç®—é€»è¾‘ï¼šä½¿ç”¨ç¡®å®šæ€§çš„é»„é‡‘èºæ—‹ç®—æ³•
            // ä¼ å…¥å½“å‰ç…§ç‰‡çš„æ€»æ•°ä½œä¸º indexï¼Œç¡®ä¿æ¯å¼ æ–°ç…§ç‰‡éƒ½æœ‰å”¯ä¸€ä¸”å‡åŒ€çš„ä½ç½®
            const index = photoMeshes.length;
            const treePos = getPhotoSurfacePosition(index);

            // Explode Position (Target) - ä¿®æ”¹ä¸ºçƒä½“åˆ†å¸ƒ
            const explodePos = getExplodeSpherePosition(35);

            mesh.position.copy(explodePos); // Start exploded if added later, or logic will fix it
            scene.add(mesh);

            photoMeshes.push({
                mesh: mesh,
                treePos: treePos,
                explodePos: explodePos,
                wobbleOffset: Math.random() * 100,
                isPhoto: true
            });
            
            // Add to main particles array for movement management
            particles.push(photoMeshes[photoMeshes.length-1]);
        }


        // --- MediaPipe Logic ---
        async function setupMediaPipe() {
            const video = document.getElementById('video-feed');

            // Access Global Hands Class
            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.6
            });

            hands.onResults(onHandsResults);

            // Access Webcam
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                await video.play();

                // Start processing loop specific to MediaPipe
                async function detectionLoop() {
                    if (video.currentTime > 0 && !video.paused && !video.ended) {
                        await hands.send({image: video});
                    }
                    requestAnimationFrame(detectionLoop);
                }
                detectionLoop();
            } catch (err) {
                console.error("Camera access denied or failed", err);
                document.getElementById('loading-text').innerText = "æœªæ£€æµ‹åˆ°æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚åº”ç”¨å°†è‡ªåŠ¨è¿è¡Œæ¼”ç¤ºæ¨¡å¼ã€‚";
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    // Auto demo mode logic could go here
                }, 2000);
            }
        }

        function onHandsResults(results) {
            const modeDisplay = document.getElementById('mode-display');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. Calculate Hand Center (for rotation)
                // Wrist is 0, Middle Finger MCP is 9
                const cx = landmarks[9].x;
                const cy = landmarks[9].y;
                handPos.x = (cx - 0.5) * 2; // -1 to 1
                handPos.y = (cy - 0.5) * 2;

                // 2. Gesture Recognition
                const state = detectGesture(landmarks);
                
                if (state) {
                    targetState = state;
                    
                    // UI Update
                    let text = "æœªçŸ¥";
                    let bg = "#333";
                    if (state === STATE.TREE) { text = "ğŸŒ² èšåˆå½¢æ€"; bg = CONFIG.colors.green; }
                    if (state === STATE.EXPLODE) { text = "âœ¨ æ•£å¼€å½¢æ€"; bg = "#444"; }
                    if (state === STATE.FOCUS) { text = "ğŸ“· èšç„¦ç…§ç‰‡"; bg = CONFIG.colors.red; }
                    
                    modeDisplay.innerText = text;
                    modeDisplay.style.borderColor = (state === STATE.FOCUS) ? '#fff' : CONFIG.colors.gold;
                }

            } else {
                isHandDetected = false;
                // Optional: Slowly drift back to tree if no hand? Or stay in last state.
                // Keeping last state is better for UX.
            }
        }

        function detectGesture(lm) {
            // Helper to check if finger is open
            const isFingerOpen = (tipIdx, pipIdx) => lm[tipIdx].y < lm[pipIdx].y; // Note: Y is inverted in some contexts, but MediaPipe y=0 is top. So tip < pip means finger up.
            // Actually, MediaPipe coords: 0,0 is top-left.
            // This assumes hand is upright. Let's use distance from wrist (0).
            
            const dist = (i, j) => Math.sqrt(Math.pow(lm[i].x - lm[j].x, 2) + Math.pow(lm[i].y - lm[j].y, 2));
            
            const wrist = 0;
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            
            // Check Fingers Extended
            let extendedCount = 0;
            // Thumb is special, check x distance relative to wrist/index for "openness"
            if (dist(4, 17) > 0.2) extendedCount++; // Rough thumb check

            for (let k=0; k<4; k++) {
                // If tip is further from wrist than PIP is from wrist
                if (dist(wrist, tips[k]) > dist(wrist, pips[k]) * 1.2) {
                    extendedCount++;
                }
            }

            // Pinch Detection (Thumb 4 and Index 8)
            const pinchDist = dist(4, 8);

            // LOGIC TREE
            // ç¨å¾®æ”¾å®½æåˆçš„åˆ¤å®šè·ç¦» (0.05 -> 0.08)ï¼Œè®©æ“ä½œæ›´çµæ•
            if (pinchDist < 0.08) {
                return STATE.FOCUS;
            } else if (extendedCount >= 4) {
                return STATE.EXPLODE;
            } else if (extendedCount <= 1) {
                return STATE.TREE;
            }
            
            return null; // No change / Transition
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 1. Smooth State Transition
            if (currentState !== targetState) {
                currentState = targetState;
                
                // If entering focus mode, pick a random photo to bring forward if any exist
                if (currentState === STATE.FOCUS && photoMeshes.length > 0) {
                     // Reset all photos first
                     photoMeshes.forEach(p => p.focusOffset = null);
                     // Pick one
                     const luckyPhoto = photoMeshes[Math.floor(Math.random() * photoMeshes.length)];
                     luckyPhoto.focusOffset = true;
                }
            }

            // 2. Camera Controls
            // Default rotation
            let camX = Math.sin(time * 0.2) * 50;
            let camZ = Math.cos(time * 0.2) * 50;
            let camY = 0;

            // Hand Influence
            if (currentState === STATE.EXPLODE && isHandDetected) {
                // Map hand x (-1 to 1) to rotation angle
                const angle = handPos.x * Math.PI; 
                camX = Math.sin(angle) * 60;
                camZ = Math.cos(angle) * 60;
                camY = handPos.y * 30;
            } else if (currentState === STATE.FOCUS) {
                // Zoom in
                camX *= 0.3;
                camZ *= 0.3;
            }

            // Lerp Camera Position
            camera.position.x += (camX - camera.position.x) * 0.05;
            camera.position.y += (camY - camera.position.y) * 0.05;
            camera.position.z += (camZ - camera.position.z) * 0.05;
            camera.lookAt(0, 0, 0);


            // 3. Particle Animation
            particles.forEach(p => {
                let target;

                if (currentState === STATE.TREE) {
                    target = p.treePos;
                } else if (currentState === STATE.EXPLODE) {
                    target = p.explodePos;
                } else if (currentState === STATE.FOCUS) {
                    // In focus mode, keep background exploded but push back slightly
                    target = p.explodePos; 
                    
                    if (p.focusOffset) {
                        // This is the chosen photo
                        // å…³é”®ä¿®æ”¹ï¼šåŠ¨æ€è®¡ç®—ç›®æ ‡ä½ç½®ï¼Œä½¿å…¶å§‹ç»ˆä½äºç›¸æœºæ­£å‰æ–¹
                        // è·å–ä»åŸç‚¹æŒ‡å‘ç›¸æœºçš„æ–¹å‘å‘é‡
                        const camDir = camera.position.clone().normalize();
                        // å°†ç…§ç‰‡æ”¾ç½®åœ¨è·ç¦»åŸç‚¹ 10 å•ä½å¤„ï¼ˆæœå‘ç›¸æœºæ–¹å‘ï¼‰
                        // è¿™æ ·æ— è®ºç›¸æœºè½¬åˆ°å“ªé‡Œï¼Œç…§ç‰‡éƒ½ä¼šåœ¨ View çš„ä¸­å¿ƒ
                        const targetPos = camDir.multiplyScalar(10);

                        p.mesh.position.lerp(targetPos, 0.1);
                        
                        // FIX: ä½¿ç”¨ copy(camera.quaternion) ç¡®ä¿ç…§ç‰‡ç»å¯¹æ­£å¯¹å±å¹•ï¼Œä¸æ­ªä¸å€’
                        p.mesh.quaternion.copy(camera.quaternion);
                        return; // Skip standard update
                    }
                }

                // Add floating effect
                const wobble = Math.sin(time * 2 + p.wobbleOffset) * 0.5;
                const finalTarget = target.clone();
                if (currentState !== STATE.TREE) {
                    finalTarget.y += wobble;
                }

                // Move mesh
                p.mesh.position.lerp(finalTarget, 0.04);
                
                // Rotation
                if (!p.isPhoto) {
                    p.mesh.rotation.x += 0.01;
                    p.mesh.rotation.y += 0.01;
                } else if (currentState === STATE.TREE) {
                    // Photos in tree mode face out from center
                    // æ ‘å½¢çŠ¶æ€ä¸‹ï¼Œè®©ç…§ç‰‡èƒŒé¢æœå‘ä¸­å¿ƒï¼Œæ­£é¢æœå¤–ï¼Œä¿æŒç›´ç«‹
                    p.mesh.lookAt(new THREE.Vector3(p.mesh.position.x * 2, p.mesh.position.y, p.mesh.position.z * 2));
                } else {
                    // FIX: Photos in explode/focus mode
                    // æ•£å¼€çŠ¶æ€ä¸‹ï¼Œä¹Ÿå¼ºåˆ¶è®©ç…§ç‰‡æ­£å¯¹å±å¹•ï¼Œé˜²æ­¢å‡ºç°å€’ç½®æˆ–æ­ªæ–œ
                    p.mesh.quaternion.copy(camera.quaternion);
                }
            });

            // æ™®é€šæ¸²æŸ“
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();

    </script>
</body>
</html>